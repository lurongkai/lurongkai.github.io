<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><style>:root{--accent-color:#FF4D4D}</style><title>.NET 4在CLR和BCL的一些变化(3)</title><meta name=description content="聊聊软件，聊聊设计，聊聊生活"><meta name=keywords content="blog,lurongkai,Ninja_Lu,software,architecture,C#,.NET,BCL"><meta property="og:url" content="https://lurongkai.github.io/posts/2010/04/13/dotnet-4-changes-on-clr-and-bcl-3/"><meta property="og:type" content="website"><meta property="og:title" content=".NET 4在CLR和BCL的一些变化(3)"><meta property="og:description" content="聊聊软件，聊聊设计，聊聊生活"><meta property="og:image" content="/images/avatar.jpeg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content=".NET 4在CLR和BCL的一些变化(3)"><meta name=twitter:description content="聊聊软件，聊聊设计，聊聊生活"><meta property="twitter:domain" content="https://lurongkai.github.io/posts/2010/04/13/dotnet-4-changes-on-clr-and-bcl-3/"><meta property="twitter:url" content="https://lurongkai.github.io/posts/2010/04/13/dotnet-4-changes-on-clr-and-bcl-3/"><meta name=twitter:image content="/images/avatar.jpeg"><link rel=canonical href=https://lurongkai.github.io/posts/2010/04/13/dotnet-4-changes-on-clr-and-bcl-3/><link rel=stylesheet type=text/css href=https://lurongkai.github.io//css/normalize.min.css media=print onload='this.media="all"'><link rel=stylesheet type=text/css href=https://lurongkai.github.io//css/main.css><link disabled id=dark-theme rel=stylesheet href=https://lurongkai.github.io//css/dark.css><script src=https://lurongkai.github.io//js/svg-injector.min.js></script>
<script src=https://lurongkai.github.io//js/feather-icons.min.js></script>
<script src=https://lurongkai.github.io//js/main.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.16/dist/katex.min.css integrity=sha384-6LkG2wmY8FK9E0vU9OOr8UvLwsaqUg9SETfpq4uTCN1agNe8HRdE9ABlk+fVx6gZ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.16/dist/katex.min.js integrity=sha384-31El76TwmbHj4rF9DyLsygbq6xoIobG0W+jqXim+a3dU9W53tdH3A/ngRPxOzzaB crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.16/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script></head><body><script type=text/javascript>setThemeByUserPref()</script><header class=header><nav class=header-nav><div class=avatar><a href=https://lurongkai.github.io/><img src=https://lurongkai.github.io//images/avatar.jpeg alt=avatar></a></div><div class=nav-title><a class=nav-brand href=https://lurongkai.github.io/>程序物语</a></div><div class=nav-links><div class=nav-link><a href=https://lurongkai.github.io/posts/>Posts</a></div><div class=nav-link><a href=https://lurongkai.github.io/tags/>Tags</a></div><div class=nav-link><a href=https://github.com/lurongkai><span data-feather=github></span></a></div><span class=nav-icons-divider></span><div class="nav-link dark-theme-toggle"><a><span id=theme-toggle-icon data-feather=moon></span></a></div><div class=nav-link id=hamburger-menu-toggle><a><span data-feather=menu></span></a></div><ul class="nav-hamburger-list visibility-hidden"><li class=nav-item><a href=https://lurongkai.github.io/posts/>Posts</a></li><li class=nav-item><a href=https://lurongkai.github.io/tags/>Tags</a></li><li class=nav-item><a href=https://github.com/lurongkai><span data-feather=github></span></a></li><li class="nav-item dark-theme-toggle"><a><span id=theme-toggle-icon data-feather=moon></span></a></li></ul></div></nav></header><main id=content><div class="post container"><div class=post-header-section><h1>.NET 4在CLR和BCL的一些变化(3)</h1><small role=doc-subtitle></small><p class=post-date>四月 13, 2010</p><ul class=post-tags><li class=post-tag><a href=https://lurongkai.github.io/tags/c>C#</a></li><li class=post-tag><a href=https://lurongkai.github.io/tags/.net>.NET</a></li><li class=post-tag><a href=https://lurongkai.github.io/tags/bcl>BCL</a></li></ul></div><div class=post-content><p><p>VS2010正式版发布了，从<a href=http://www.cnblogs.com/gnielee/archive/2010/04/12/dot-net-framework-4-namespace.html>海报</a>中我们可以看到.NET 4在BCL上的改进还是很大的，这一次主要讨论比较Core的变化。</p><p>就照海报的顺序说吧。</p><h2 id=systemcollectionsgeneric>System.Collections.Generic</h2><p>.NET 4中新加入了名为<code>SortedSet&lt;T></code>的结构，这是一个很有用的结构，它在内部维护一个集合，使用<code>Add()</code>向<code>SortedSet</code>中添加已存在的项时会被忽略，并且返回<code>false</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>SortedSet sortedSetDemo = <span style=color:#ff79c6>new</span> SortedSet { <span style=color:#bd93f9>8</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>5</span>, <span style=color:#bd93f9>10</span>, <span style=color:#bd93f9>5</span>, <span style=color:#bd93f9>10</span>, <span style=color:#bd93f9>8</span> };
</span></span></code></pre></div><p>SortedSet和HashSet均实现了新引入的<code>ISet</code>接口，其实可以看下<code>ISet</code>的签名：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#ff79c6>public</span> <span style=color:#ff79c6>interface</span> <span style=color:#50fa7b>ISet</span>&lt;T&gt; : ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, IEnumerable
</span></span></code></pre></div><p>于是可以知道SortedSet是一个集合，同时可遍历，可……</p><h2 id=systemiomemorymappedfiles>System.IO.MemoryMappedFiles</h2><p>这个结构的作用在于将一个文映射到内存中，以达到快速“IO”的目的。其实<code>MemoryMappedFiles</code>的真正作用是用作进程间或应用程序间的通信，在内存映射文件中存储相关的信息然后传递。下面这个例子简单演示了如何使用<code>MemoryMappedFiles</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#ff79c6>using</span> System.IO;
</span></span><span style=display:flex><span><span style=color:#ff79c6>using</span> System.IO.MemoryMappedFiles;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>using</span> (MemoryMappedFile MemoryMappedFile = MemoryMappedFile.CreateNew(<span style=color:#f1fa8c>&#34;MemoryMappedFileDemo&#34;</span>, <span style=color:#bd93f9>100</span>)){
</span></span><span style=display:flex><span>	MemoryMappedViewStream stream = MemoryMappedFile.CreateViewStream();
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>using</span> (BinaryWriter writer = <span style=color:#ff79c6>new</span> BinaryWriter(stream)){
</span></span><span style=display:flex><span>		writer.Write(<span style=color:#f1fa8c>&#34;hello cnblogs&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样我们就将一个名为<code>MemoryMappedFileDemo</code>的“文件”写入到了内存，下面的代码说明怎样将它读出来，要注意的是，两段代码不要写在一个应用程序内，否则会报错。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#ff79c6>using</span> (MemoryMappedFile MemoryMappedFile = MemoryMappedFile.OpenExisting(<span style=color:#f1fa8c>&#34;MemoryMappedFileDemo&#34;</span>))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>using</span> (MemoryMappedViewStream Stream = MemoryMappedFile.CreateViewStream())
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		BinaryReader reader = <span style=color:#ff79c6>new</span> BinaryReader(Stream);
</span></span><span style=display:flex><span>		Console.WriteLine(reader.ReadString());
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>难能可贵的是，VS2010对<code>MemoryMappedFileDemo</code>提供Debug支持。</p><p><img src=1.jpeg alt="Debug Support"></p><h2 id=systemnumerics>System.Numerics</h2><p>.NET 4新加入的命名空间，里面包含了两个数据结构：<code>BigInteger</code>和<code>Complex</code>。<code>BigInteger</code>提供了比整型长度更长的数值表示范围，默认值为0，且为不可变类型，如果一些比较特殊的场景整型满足不了需求，可以考虑使用<code>BigInteger</code>，相关的辅助方法也会加快的开发效率。</p><p>需要注意的是，很多情况下需要手动的引用System.Numberics所在的程序集：</p><p><img src=2.png alt="Debug Support"></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>BigInteger bigIntegerDemo = <span style=color:#ff79c6>new</span> BigInteger(<span style=color:#bd93f9>9999999999999999</span>);
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span> (bigIntegerDemo.IsZero) {
</span></span><span style=display:flex><span>	Console.WriteLine(<span style=color:#f1fa8c>&#34;Equal 0&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>Console.WriteLine(bigIntegerDemo);
</span></span></code></pre></div><p>而<code>Complex</code>则是我们常说的复数类。就像平学数学中的定义一样，一个复数由一个实部与虚部构成：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Complex n1 = <span style=color:#ff79c6>new</span> Complex(<span style=color:#bd93f9>8</span>, <span style=color:#bd93f9>2</span>);
</span></span><span style=display:flex><span>Complex n2 = <span style=color:#ff79c6>new</span> Complex(<span style=color:#bd93f9>8</span>, <span style=color:#bd93f9>2</span>);
</span></span><span style=display:flex><span>Complex n3 = n1 + n2;
</span></span></code></pre></div><h2 id=systemtuple结构>System.Tuple结构</h2><p><code>Tuple</code>(元组)是一个大小固定的集合主要被设计为与<code>F#</code>，<code>IronPython</code>等互操作。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#8be9fd>var</span> primes = Tuple.Create(<span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>5</span>, <span style=color:#bd93f9>7</span>, <span style=color:#bd93f9>11</span>, <span style=color:#bd93f9>13</span>, <span style=color:#bd93f9>17</span>, <span style=color:#bd93f9>19</span>);
</span></span></code></pre></div><p>这是一个MSDN官方的例子，完整的元组使用应该是这样：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Tuple&lt;<span style=color:#8be9fd>int</span>, <span style=color:#8be9fd>int</span>, <span style=color:#8be9fd>int</span>, <span style=color:#8be9fd>int</span>, <span style=color:#8be9fd>int</span>, <span style=color:#8be9fd>int</span>, <span style=color:#8be9fd>int</span>, Tuple&lt;<span style=color:#8be9fd>int</span>&gt;&gt; primes = Tuple.Create(<span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>5</span>, <span style=color:#bd93f9>7</span>, <span style=color:#bd93f9>11</span>, <span style=color:#bd93f9>13</span>, <span style=color:#bd93f9>17</span>, <span style=color:#bd93f9>19</span>);
</span></span></code></pre></div><p>因为一个元组最大为6，所以想扩展元组必须在最后一个位置上再加一个元组。有了<code>var</code>关键字，便使整个过程更简单了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#8be9fd>var</span> multiTuple = <span style=color:#ff79c6>new</span> Tuple&lt;<span style=color:#8be9fd>int</span>, <span style=color:#8be9fd>int</span>, <span style=color:#8be9fd>int</span>, <span style=color:#8be9fd>int</span>, <span style=color:#8be9fd>int</span>, <span style=color:#8be9fd>int</span>, <span style=color:#8be9fd>int</span>,Tuple&lt;<span style=color:#8be9fd>int</span>,<span style=color:#8be9fd>int</span>,<span style=color:#8be9fd>int</span>&gt;&gt;(
</span></span><span style=display:flex><span>	<span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>4</span>, <span style=color:#bd93f9>6</span>, <span style=color:#bd93f9>8</span>, <span style=color:#bd93f9>10</span>, <span style=color:#bd93f9>12</span>, <span style=color:#bd93f9>14</span>,
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>new</span> Tuple&lt;<span style=color:#8be9fd>int</span>,<span style=color:#8be9fd>int</span>,<span style=color:#8be9fd>int</span>&gt;(<span style=color:#bd93f9>3</span>,<span style=color:#bd93f9>6</span>,<span style=color:#bd93f9>9</span>));
</span></span></code></pre></div><p>访问也简单：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>primes.Item1;<span style=color:#6272a4>//2</span>
</span></span><span style=display:flex><span>primes.Item2;<span style=color:#6272a4>//3</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>//...</span>
</span></span><span style=display:flex><span>multiTuple.Rest.Item1;<span style=color:#6272a4>//3</span>
</span></span></code></pre></div><h2 id=systemruntiimeinteropservices>System.Runtiime.InteropServices</h2><p>新提供的<code>TypeIdentifierAttribute</code>特性，可以为一些在类型库中没有<code>GUID</code>的类型提供等价类型支持，只需在类型上加<code>[TypeIdentifier]</code>即可。</p><p>关于.NET 4中Parallel的部分在这个系列的第一篇有部分介绍，我打算将详细的部分例如PLINQ，放到后面的系列来具体讨论。</p><h2 id=已有类的改进>已有类的改进</h2><ul><li><code>Stopwatch</code>: <code>Stopwathc</code>中新加入了<code>Restart()</code>方法，方便我们重置计时器。</li><li><code>Environment</code>: 加入了关于CPU和OS是否为64位的属性：<code>Is64BitProcess</code>，<code>Is64BitOperatingSystem</code>，并且为了便于使用系统文件夹，新增了一个名为<code>SpecialFolder</code>的枚举类型，<code>Environment.SpecialFolder.Desktop</code>则表示桌面，<code>Environment.SpecialFolder.CommonMusic</code>表示公用音乐文件夹。</li><li><code>Stream</code>: 加入<code>CopyTo</code>方法，可以快捷的从一个流拷贝数据到另一个流。</li><li><code>Enum</code>: 过去判断一个[Flag]枚举是否包含某个标志时，通常会使用<code>&</code>运算判断是否为空，.NET 4为<code>Enum</code>提供了一个更为简便的方法：<code>HasFlag()</code>，例如：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#50fa7b>[Flags]</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>public</span> <span style=color:#ff79c6>enum</span> DataOptions
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	Data1 = <span style=color:#bd93f9>1</span>,
</span></span><span style=display:flex><span>	Data2 = <span style=color:#bd93f9>2</span>,
</span></span><span style=display:flex><span>	Data3 = <span style=color:#bd93f9>4</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>然后可以使用<code>HasFlag()</code>来判断是否存在某个标志：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>DataOptions data = DataOptions.Data1 | DataOptions.Data2 | DataOptions.Data3;
</span></span><span style=display:flex><span>Console.WriteLine(<span style=color:#f1fa8c>&#34;Have Data2? {0}&#34;</span>, data.HasFlag(DataOptions.Data2));
</span></span></code></pre></div><ul><li><code>Guid</code>，<code>Version</code>，<code>Enum</code>: 现在均增加了对应的<code>TryParse</code>方法。</li><li><code>String</code>: 新增支持<code>IEnumerable</code>的<code>Concat()</code>，<code>Join()</code>方法，使用<code>LINQ</code>更加的方便，<code>IsNullOrWhiteSpace()</code>方法的加入也使对字符串的判断上更加的严谨。</li><li><code>File</code>: 新增支持<code>IEnumerable</code>的<code>ReadLines()</code>方法，<code>WriteAllLines()</code>，<code>AppendAllLines()</code>也做为配合而出现，接受<code>IEnumerable</code>参数。有理由相信<code>Directory</code>是否也有相关的变化，答案是有，具体参见MSDN。</li></ul><p>.NET 4的变化很多，一些新特性有待大家一起发掘，更多的内容还是需要在实际的实用中慢慢的体会。下一次如果机会恰当，将研究一些.NET 4特定的技术例如PLINQ等等，不完全局限于CLR和BCL，因为这个话题真正写起来了才发现很空泛，很寂寞……</p></p></div><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//software_story.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></main><footer class=footer><span>&copy; 2022 Lu Rongkai</span>
<span>Made with &#10084;&#65039; using <a target=_blank href=https://github.com/526avijitgupta/gokarna>Gokarna</a></span></footer></body></html>