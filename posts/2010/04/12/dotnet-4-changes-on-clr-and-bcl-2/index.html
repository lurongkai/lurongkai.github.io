<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><style>:root{--accent-color:#FF4D4D}</style><title>.NET 4在CLR和BCL的一些变化(2)</title><meta name=description content="聊聊软件，聊聊设计，聊聊生活"><meta name=keywords content="blog,lurongkai,Ninja_Lu,software,architecture,C#,.NET,BCL"><meta property="og:url" content="https://lurongkai.github.io/posts/2010/04/12/dotnet-4-changes-on-clr-and-bcl-2/"><meta property="og:type" content="website"><meta property="og:title" content=".NET 4在CLR和BCL的一些变化(2)"><meta property="og:description" content="聊聊软件，聊聊设计，聊聊生活"><meta property="og:image" content="/images/avatar.jpeg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content=".NET 4在CLR和BCL的一些变化(2)"><meta name=twitter:description content="聊聊软件，聊聊设计，聊聊生活"><meta property="twitter:domain" content="https://lurongkai.github.io/posts/2010/04/12/dotnet-4-changes-on-clr-and-bcl-2/"><meta property="twitter:url" content="https://lurongkai.github.io/posts/2010/04/12/dotnet-4-changes-on-clr-and-bcl-2/"><meta name=twitter:image content="/images/avatar.jpeg"><link rel=canonical href=https://lurongkai.github.io/posts/2010/04/12/dotnet-4-changes-on-clr-and-bcl-2/><link rel=stylesheet type=text/css href=https://lurongkai.github.io//css/normalize.min.css media=print onload='this.media="all"'><link rel=stylesheet type=text/css href=https://lurongkai.github.io//css/main.css><link disabled id=dark-theme rel=stylesheet href=https://lurongkai.github.io//css/dark.css><script src=https://lurongkai.github.io//js/svg-injector.min.js></script>
<script src=https://lurongkai.github.io//js/feather-icons.min.js></script>
<script src=https://lurongkai.github.io//js/main.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.16/dist/katex.min.css integrity=sha384-6LkG2wmY8FK9E0vU9OOr8UvLwsaqUg9SETfpq4uTCN1agNe8HRdE9ABlk+fVx6gZ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.16/dist/katex.min.js integrity=sha384-31El76TwmbHj4rF9DyLsygbq6xoIobG0W+jqXim+a3dU9W53tdH3A/ngRPxOzzaB crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.16/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script></head><body><script type=text/javascript>setThemeByUserPref()</script><header class=header><nav class=header-nav><div class=avatar><a href=https://lurongkai.github.io/><img src=https://lurongkai.github.io//images/avatar.jpeg alt=avatar></a></div><div class=nav-title><a class=nav-brand href=https://lurongkai.github.io/>程序物语</a></div><div class=nav-links><div class=nav-link><a href=https://lurongkai.github.io/posts/>Posts</a></div><div class=nav-link><a href=https://lurongkai.github.io/tags/>Tags</a></div><div class=nav-link><a href=https://github.com/lurongkai><span data-feather=github></span></a></div><span class=nav-icons-divider></span><div class="nav-link dark-theme-toggle"><a><span id=theme-toggle-icon data-feather=moon></span></a></div><div class=nav-link id=hamburger-menu-toggle><a><span data-feather=menu></span></a></div><ul class="nav-hamburger-list visibility-hidden"><li class=nav-item><a href=https://lurongkai.github.io/posts/>Posts</a></li><li class=nav-item><a href=https://lurongkai.github.io/tags/>Tags</a></li><li class=nav-item><a href=https://github.com/lurongkai><span data-feather=github></span></a></li><li class="nav-item dark-theme-toggle"><a><span id=theme-toggle-icon data-feather=moon></span></a></li></ul></div></nav></header><main id=content><div class="post container"><div class=post-header-section><h1>.NET 4在CLR和BCL的一些变化(2)</h1><small role=doc-subtitle></small><p class=post-date>四月 12, 2010</p><ul class=post-tags><li class=post-tag><a href=https://lurongkai.github.io/tags/c>C#</a></li><li class=post-tag><a href=https://lurongkai.github.io/tags/.net>.NET</a></li><li class=post-tag><a href=https://lurongkai.github.io/tags/bcl>BCL</a></li></ul></div><div class=post-content><p><p>上一篇讨论了.NET 4中关于垃圾回收、线程、并行、全球化等方面的内容，这次我们接着上次往下说。</p><h2 id=安全>安全</h2><p>安全是一个很大的概念。在.NET 4中，主要的改进在于对CAS操作的简化。</p><p>先前的版本中，如果想要控制资源的安全访问，那么就会使用CAS策略，但是操作往往很复杂，4改进了操作，主要体现在这些方面：</p><p>改进的透明模型。透明模型将代码分为了安全、不安全、或许安全，当然，这取决于程序宿主机的设置。于是.NET为不同应用程序设置了不同的安全类型，就像我们平常知道的那样，ASP.NET和SQL, Silverlight可以运行代码的安全级别都不一样，这都是CAS策略所管理的。先前的透明模型主要和一些代码检查工具如FxCop等协同来审核代码。</p><p>透明模型有三种类型：透明代码、关键代码、安全关键代码，分别代表的代码的不同安全等级。当.NET 4的应用程序以部分信任运行时，CLR将确保透明代码可以调用其它的透明和安全的代码。并且，在程序调用安全的同时，CLR要求一定的权限才能执行，这个权限是通过程检查程序宿主机的设置来确认的。</p><p>与过去不同的是，.NET 4将通过Windows Explorer和网络共享运行的代码定义为完全信任，换句话讲，它们的等级是相同的，而先前的版本中，两者的运行等级并不相同。而运行在主机的应用程序，不管是ASP.NET或是Silverlight，将使用主机授权，也就是说我们只需要考虑授权这些应用程序以不同的权限。部分信任的应用程序已经对其有了必要的限制，对于非本机的代码，微软建议我们使用SRPs(Software Restriction Policies软件限制策略)来应用安全策略，这个东东可以在托管代码和非托管代码上应用，具体的大家查查MSDN。</p><p>新的版本中，已经删除了在CLR中有关<code>Deny</code>, <code>RequestMinimum</code>, <code>RequestOptional</code>, <code>RequestRefuse</code>的权限要求，所以说如果要迁移程序到新版本，一定要删除相关的代码才行，不然会报错。</p><p>缝缝补补，.NET 4终于可以不用像以前那样繁琐的来控制应用程序的权限相关的问题了。另外值得注意的是，.NET 4中有了一个<code>PartialTrustVisibilityLevel</code>的特性(Attribute)，使用这个特性，我们可以在部分信任的应用程序中，调用一些需要完全信任权限才能调用的程序集，这对于我们是一个好消息，尤其是ASP.NET应用程序。CAS的使用需要辅以“证据”，我们可以看看下图中CAS的构建模块：</p><p><img src=1.jpeg alt=CAS></p><p>.NET 4中的证据类型基类Evidence现在可以确保继承它的证据类型是非空和可序列化的。额外的，新加入了一些方法可以用于查询证据的具体类型，这在先前的版本中是通过遍历来实现的。</p><h2 id=监测与分析>监测与分析</h2><p>.NET 4的改进中不得不提的是，我们现在可以获取每个应用程序域关于CPU和内存的使用情况了，这对于ASP.NET应用程序是个不错的功能，很多时候我们需要知道应用程序的状况来做相关的优化时却措手无策，现在好了，新的改进可以使开发人员从容淡定的了解其应用程序的运行状况，然后淡定的修修补补，OK，效率上去了。</p><p>当然了，新的API肯定是有的，新增的API可以用做profiling和debugging，总的原则就是改善程序员的生存状态，不要累死在Debug上，嗯。</p><p>监测程序不正常的传统做法就是异常处理，我们经常这么做：</p><pre tabindex=0><code>try {
	//Do some thing
} catch(System.exception e) {
	//...
}
</code></pre><p>这种做法很不推荐，因为所有的异常将被隐藏，然而我们往往希望一些异常不要被捕获，例如一些可以访问冲突或者调用非法指令的异常，这时应该让程序在出现异常时退出来而不是由catch将所有的异常捕获，因为这些异常具有一定潜在的危险性。.NET 4中引入了新的特性，那就是在方法体上标注<code>[HandleProcessCorruptedStateExceptions]</code>，这样，当破坏状态的异常出现时，将不会被catch捕获了。</p><p>那如果想捕获这些破坏状态的异常，比如将它传递到一个异常Logging类，好办，应用程序配置文件里加入这么一行：<code>LegacyCorruptedStateExceptionsPolicy = true</code>，catch就可以捕获到它了。</p><h2 id=dynamic的引入与dlr>Dynamic的引入与DLR</h2><p>这个特性绝对是.NET 4的重头戏，将它与Parallel特性封为4上最重要的功能一点也不过分。</p><p>先让我们来看一下先前版本的.NET对加入动态语言到.NET框架时是怎么做的：</p><p><img src=2.jpeg alt="dynamic before"></p><p>可以看的出，Python和Ruby等这些动态语言是通过直接原生的在CLR上编写而实现移植。我们有理由想像在一个非动态的运行时上实现动态语言的难度是何等之大！</p><p>.NET 4提出的DLR是一个动态语言运行时，也就是说是微软官方提供的在CLR的基础上提供一层动态语言抽象层，来实现“门门语言为我，我为门门语言”的大友好框架主义，在此特性上，要移植一门动态语言到.NET平台上，好，去找DLR，那静态语言呢？直接去搞CLR。举个例子，今天我看上Javascript这姑娘了，想搞出个Javascript.NET，以实现我浏览器大友好.NET主义，理论上可行，可以联系DLR大哥；隔天又看上Java了……算了，我们换个例子，看上Scale了，好，给你张CLR的名片，我等.NET民众合谐友好。</p><p>那么具体的DLR在.NET 4所处的处置就是下面这个样子：</p><p><img src=3.jpeg alt="dynamic now"></p><p>咦？C#和VB也可以使用DLR？当然了，为了交互的方便么。所以我们可以介绍怎样在C#等静态语言中使用动态语言的功能了。</p><p>于是我们有理由相信，.NET 4上的语言会越来越多，事实从<a href=http://www.dotnetlanguages.net/DNL/Resources.aspx>一些消息</a>上看，好像已经有二三十种的样子，著名的好像还是一些比较大的语言。当Python和Ruby在DLR上开始构建时，我相信可以实现的灵活度会大大提高。下面是官方的一张PPT：</p><p><img src=4.jpeg alt="dynamic ppt"></p><p>当然了，这是编程层面的东西，例如C#和VB.NET其实是构建在CLR上的，只不过可以通过DLR来实现一些动态编程的特性。</p><p>.NET 4新加入的动态功能可以使我们方便的在运行时获取一个未知类型的对象并对其进行操作。同样的，构建在DLR基础上的动态语言也可以通过DLR -> CLR的方式来使用.NET类库。所以我们有理由相信，在使用COM方面，也将更加的简化。</p><p>动态语言是指在编译期不进行类型检查，在运行时动态的确定类型，这样的做的好处在于我们不必对未知的类型进行抽象，完全将其放在运行时动态的解析。然而其缺点也显而易见，那就是无法使用智能感知等强类型语言才拥有的特性，因此Debug也相对较困难一些。值得注意的是，动态语言的运行效率一定不会很高，因为在运行时进行解析是非常耗费资源的，并且对DLR来说，多一层抽象所带来的性能损失绝不对小视。我们可以想像一下将C#移植到Java平台上或者相反，理论上完全可行，因为.NET平台Java平台具有一定的相似性，对Java Bytecode和MSIL之间转换即可，然而效率问题确值得商榷。多一层抽象就多一层损耗，所以，在静态语言中使用动态特性一定要谨慎，不要滥用。</p><p>但是如果好奇，那么我们可以写个用反射来使用动态特性的Demo：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#8be9fd>object</span> UsingReflection = Activator.CreateInstance(Type.GetType(<span style=color:#f1fa8c>&#34;System.Text.StringBuilder&#34;</span>));
</span></span><span style=display:flex><span>Type ObjectType = UsingReflection.GetType();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>//Append有很多的重载，所以需要指定反射使用哪个重载</span>
</span></span><span style=display:flex><span>Type[] TypeArray = <span style=color:#ff79c6>new</span> Type[<span style=color:#bd93f9>1</span>];
</span></span><span style=display:flex><span>TypeArray.SetValue(<span style=color:#ff79c6>typeof</span>(<span style=color:#8be9fd>string</span>), <span style=color:#bd93f9>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>var</span> ObjectMethodInfo = ObjectType.GetMethod(<span style=color:#f1fa8c>&#34;Append&#34;</span>, TypeArray);
</span></span><span style=display:flex><span>ObjectMethodInfo.Invoke(UsingReflection, <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>object</span>[] { <span style=color:#f1fa8c>&#34;alex&#34;</span> });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Console.WriteLine(ObjectType
</span></span><span style=display:flex><span>	.GetMethod(<span style=color:#f1fa8c>&#34;ToString&#34;</span>, <span style=color:#ff79c6>new</span> Type[<span style=color:#bd93f9>0</span>])
</span></span><span style=display:flex><span>	.Invoke(UsingReflection, <span style=color:#ff79c6>null</span>));
</span></span><span style=display:flex><span>上面是使用反射的方式来动态使用StringBuilder的Append和ToString的示例，不知道您看的怎么样，反正弄的我晕晕。
</span></span></code></pre></div><p>我们可不可以换个优美的方式，至少，能不能像我们平常使用StringBuilder一样呢？在.NET 4，有了，使用DLR的特性就可以优美和谐一些了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#8be9fd>dynamic</span> usingDynamic = Activator .CreateInstance(Type.GetType(<span style=color:#f1fa8c>&#34;System.Text.StringBuilder&#34;</span>));
</span></span><span style=display:flex><span>usingDynamic.Append(<span style=color:#f1fa8c>&#34;Hello&#34;</span>);
</span></span><span style=display:flex><span>Console.WriteLine(usingDynamic.ToString());
</span></span></code></pre></div><p>很好很强大不是么？但是要再次重申：性能，性能！不到一定的成本和效率的折中点时，不要用！</p><p>也许很大人奇怪var关键字和dynamic关键字的异同，答案是：不同。var其实就是一个编译器魔法，在编译时将其替换成了强类型，所以我们可以使用智能感应来写代码，并提高了书写代码的效率，然而dynamic关键字的声明意味着您的代码将会在运行时进行真正的赋值（？解释有些模糊），所以在写上面代码时，例如<code>usingDynamic.Append("Hello")</code>;是完全没有智能感应的。我们可以期待微软在下一个版本将智能感应加进去，然后这将对机器性能是一个极大的考验，因为为了智能感应需要去实时的解析未知类型才能使我们优美的使用“.”来一路点下去……手指可以优美，机器不一定就优美了。</p><p>我们还可以这么做：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#ff79c6>using</span> System.Dynamic;
</span></span><span style=display:flex><span><span style=color:#8be9fd>dynamic</span> toCreateType = <span style=color:#ff79c6>new</span> ExpandoObject();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>toCreateType.Name = <span style=color:#f1fa8c>&#34;LuRongkai&#34;</span>;
</span></span><span style=display:flex><span>toCreateType.Age = <span style=color:#bd93f9>21</span>;
</span></span><span style=display:flex><span>toCreateType.ShowInfo = <span style=color:#ff79c6>new</span> Action(() =&gt; Console.WriteLine(<span style=color:#f1fa8c>&#34;My age:&#34;</span>, toCreateType.Age));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Console.WriteLine(toCreateType.Name);
</span></span><span style=display:flex><span>toCreateType.ShowInfo();
</span></span><span style=display:flex><span>Console.ReadKey();
</span></span></code></pre></div><p>结果显示：</p><pre tabindex=0><code>LuRongkai
My age:21
</code></pre><p>Cool，不是么？如果想要进一步控制对象在运行时的特性，可以使用<code>System.Dynamic.DynamicObject</code>对象，可以继承它来使用，我写了个例子来说明一下这个对象的使用方式：</p><p>首先，定义一定SimpleXML类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#ff79c6>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>SimpleXML</span> : DynamicObject{
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>private</span> XDocument <span style=color:#bd93f9>_</span>xml = <span style=color:#ff79c6>new</span> XDocument();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>public</span> SimpleXML(<span style=color:#8be9fd>string</span> Xml){
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>this</span>.<span style=color:#bd93f9>_</span>xml = XDocument.Parse(Xml);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>public</span> <span style=color:#ff79c6>override</span> <span style=color:#8be9fd>bool</span> TryGetMember(GetMemberBinder binder, <span style=color:#ff79c6>out</span> <span style=color:#8be9fd>object</span> result){
</span></span><span style=display:flex><span>		<span style=color:#8be9fd>string</span> nodeName = binder.Name;
</span></span><span style=display:flex><span>		result = <span style=color:#bd93f9>_</span>xml.Element(<span style=color:#f1fa8c>&#34;root&#34;</span>).Element(nodeName).Value;
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>下面我们就可以使用动态的语言的特性来使用了，这里先简单的创建一个了测试的XML文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#ff79c6>using</span> System.Dynamic;
</span></span><span style=display:flex><span><span style=color:#ff79c6>using</span> System.Xml.Linq;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>dynamic</span> simpleXML = <span style=color:#ff79c6>new</span> SimpleXML(<span style=color:#f1fa8c>@&#34;LuRongkai21&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Console.WriteLine(simpleXML.data1);
</span></span><span style=display:flex><span>Console.WriteLine(simpleXML.data2);
</span></span></code></pre></div><p>优美，优美，优美！性能，性能，性能！</p><p>.NET 4中的重头戏就是Parallel和Dynamic，我们有理由相信今天的VS2010的发布将会给世界带来震撼，虽然这几篇文章是要讨论CLR和BLR的，但是没能忍住，好吧，下一次讨论BCL的一些new features。</p></p></div><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//software_story.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></main><footer class=footer><span>&copy; 2022 Lu Rongkai</span>
<span>Made with &#10084;&#65039; using <a target=_blank href=https://github.com/526avijitgupta/gokarna>Gokarna</a></span></footer></body></html>