<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><style>:root{--accent-color:#FF4D4D}</style><title>.NET 4中的并行编程(下)</title><meta name=description content="聊聊软件，聊聊设计，聊聊生活"><meta name=keywords content="blog,lurongkai,Ninja_Lu,software,architecture,C#,.NET,Parallel"><meta property="og:url" content="https://lurongkai.github.io/posts/2010/04/20/dotnet-parallel-programming-2/"><meta property="og:type" content="website"><meta property="og:title" content=".NET 4中的并行编程(下)"><meta property="og:description" content="聊聊软件，聊聊设计，聊聊生活"><meta property="og:image" content="/images/avatar.jpeg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content=".NET 4中的并行编程(下)"><meta name=twitter:description content="聊聊软件，聊聊设计，聊聊生活"><meta property="twitter:domain" content="https://lurongkai.github.io/posts/2010/04/20/dotnet-parallel-programming-2/"><meta property="twitter:url" content="https://lurongkai.github.io/posts/2010/04/20/dotnet-parallel-programming-2/"><meta name=twitter:image content="/images/avatar.jpeg"><link rel=canonical href=https://lurongkai.github.io/posts/2010/04/20/dotnet-parallel-programming-2/><link rel=stylesheet type=text/css href=https://lurongkai.github.io//css/normalize.min.css media=print onload='this.media="all"'><link rel=stylesheet type=text/css href=https://lurongkai.github.io//css/main.css><link disabled id=dark-theme rel=stylesheet href=https://lurongkai.github.io//css/dark.css><script src=https://lurongkai.github.io//js/svg-injector.min.js></script>
<script src=https://lurongkai.github.io//js/feather-icons.min.js></script>
<script src=https://lurongkai.github.io//js/main.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.16/dist/katex.min.css integrity=sha384-6LkG2wmY8FK9E0vU9OOr8UvLwsaqUg9SETfpq4uTCN1agNe8HRdE9ABlk+fVx6gZ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.16/dist/katex.min.js integrity=sha384-31El76TwmbHj4rF9DyLsygbq6xoIobG0W+jqXim+a3dU9W53tdH3A/ngRPxOzzaB crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.16/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script></head><body><script type=text/javascript>setThemeByUserPref()</script><header class=header><nav class=header-nav><div class=avatar><a href=https://lurongkai.github.io/><img src=https://lurongkai.github.io//images/avatar.jpeg alt=avatar></a></div><div class=nav-title><a class=nav-brand href=https://lurongkai.github.io/>程序物语</a></div><div class=nav-links><div class=nav-link><a href=https://lurongkai.github.io/posts/>Posts</a></div><div class=nav-link><a href=https://lurongkai.github.io/tags/>Tags</a></div><div class=nav-link><a href=https://github.com/lurongkai><span data-feather=github></span></a></div><span class=nav-icons-divider></span><div class="nav-link dark-theme-toggle"><a><span id=theme-toggle-icon data-feather=moon></span></a></div><div class=nav-link id=hamburger-menu-toggle><a><span data-feather=menu></span></a></div><ul class="nav-hamburger-list visibility-hidden"><li class=nav-item><a href=https://lurongkai.github.io/posts/>Posts</a></li><li class=nav-item><a href=https://lurongkai.github.io/tags/>Tags</a></li><li class=nav-item><a href=https://github.com/lurongkai><span data-feather=github></span></a></li><li class="nav-item dark-theme-toggle"><a><span id=theme-toggle-icon data-feather=moon></span></a></li></ul></div></nav></header><main id=content><div class="post container"><div class=post-header-section><h1>.NET 4中的并行编程(下)</h1><small role=doc-subtitle></small><p class=post-date>四月 20, 2010</p><ul class=post-tags><li class=post-tag><a href=https://lurongkai.github.io/tags/c>C#</a></li><li class=post-tag><a href=https://lurongkai.github.io/tags/.net>.NET</a></li><li class=post-tag><a href=https://lurongkai.github.io/tags/parallel>Parallel</a></li></ul></div><div class=post-content><p><p>上一次主要讨论了在.NET 4中如何编写并行程序，这次继续上次的话题。</p><p>当我们有能力使用前面所介绍的一些结构来构建我们的应用程序时，一个需要考虑的场景是：假如一个并行过程已经开始，在它没有完成前想取消它的话应该怎么做呢？其实这个问题很现实，在多线程程序中也会遇到，当然了，多线程编程时我们可以用Thread.Abort()来终结它，那么在并行中该如何实现呢？老规矩，上Demo：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>CancellationTokenSource tokenSource = <span style=color:#ff79c6>new</span> CancellationTokenSource();
</span></span><span style=display:flex><span>CancellationToken token = tokenSource.Token;
</span></span><span style=display:flex><span>Task task1 = Task.Factory.StartNew(() =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> i = <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (!token.IsCancellationRequested) {
</span></span><span style=display:flex><span>        Thread.Sleep(<span style=color:#bd93f9>500</span>);
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#f1fa8c>&#34;Task1,{0}&#34;</span>, i++);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}, token);
</span></span><span style=display:flex><span>token.Register(() =&gt; {
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#f1fa8c>&#34;Task1 has been canceled&#34;</span>);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Console.ReadLine();
</span></span><span style=display:flex><span>tokenSource.Cancel();
</span></span></code></pre></div><p>首先实例化一个CancellationTokenSource对象，这个对象用于管理并行过程中的取消动作。当创建一个Task的时候，传入一个CancellationToken对象，而这个对象可以由CancellationTokenSource.Token属性来获得。当Task开开始执行时，如果想取消这个Task，那么就可以调用CancellationTokenSource.Cancel()来取消与之相关的Task了。</p><p>其实，我们可以将CancellationTokenSource理解为一个犯罪团伙的头目，然后这个头目管理着CancellationToken小兵，然后当一个Task创建时将这个小兵安插在其中(无间道？)，当头目发指令Cancel()时，小兵在Task内部上演无间道，嗯……</p><p>然而，出来混，迟早要还的。Task能不能无异常的执行完毕还是个未知数。在.NET 4中，现在可以用AggregateException来处理这些异常了，它提供一种异常汇总机制，可以对未知的异常进行处理，上一个Demo：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Task task1 = Task.Factory.StartNew(() =&gt; {
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#f1fa8c>&#34;Task1 completed.&#34;</span>);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>Task task2 = Task.Factory.StartNew(() =&gt; {
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#f1fa8c>&#34;Task2 processing.&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>throw</span> <span style=color:#ff79c6>new</span> ArgumentOutOfRangeException(<span style=color:#f1fa8c>&#34;task2&#34;</span>);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>try</span> {
</span></span><span style=display:flex><span>    Task.WaitAll(task1, task2);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#ff79c6>catch</span> (AggregateException aggex) {
</span></span><span style=display:flex><span>    aggex.Handle(ex =&gt; {
</span></span><span style=display:flex><span>        Console.WriteLine(ex);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以将具体的异常处理写在AggregateException.Handle方法内，Handle方法传入一个Func委托，用于处理具体的异常，例如上面，我们只是在Task内简单的抛出了一个ArgumentOutOfRangeException异常，当调用Task.WaitAll时异常被捕获，然后在aggex.Handle中具体处理。当然，可以将上述中传入的ex进行is判断来确定具体的异常，例如：if (ex is ArgumentOutOfRangeException) {…}。</p><p>聊完异常处理，接着聊访问安全。</p><p>访问安全的问题其实很显然，在多线程环境下要注意的问题无疑都是要在并行环境下考虑。这里，其实可以用线程安全来讲，因为不管是多线程还是并行，CPU调度的最小单位都是线程，所以，以下都用线程安全来说明。</p><p>要求线程安全，首先想到的肯定就是上锁。过去的一些手段就不说了，我们着重说一下.NET 4中的SpinLock互斥锁。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>SpinLock spinLock = <span style=color:#ff79c6>new</span> SpinLock();
</span></span><span style=display:flex><span><span style=color:#8be9fd>bool</span> locked = <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span><span style=color:#ff79c6>try</span> {
</span></span><span style=display:flex><span>    spinLock.Enter(<span style=color:#ff79c6>ref</span> locked);
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Do something.</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#ff79c6>finally</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (locked) {
</span></span><span style=display:flex><span>        spinLock.Exit();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>其实不用解释也看的懂了。线程安全操作多用于对资源的访问控制上，例如IO，Stream等，而我们往往需要面对的其实是内存中的数据，例如集合，例如队列等。.NET 4为了并行，引入了一个新的命名空间：System.Collections.Concurrent;在这个空间之下有很多经过处理的基础结构，例如ConcurrentDictionary、ConcurrentQueue等，它们都是线程安全的，或者说是并行安全的，而且在使用方法上和见的System.Collections.Generic下的结构无异。接下来演示一个BlockingCollection结构的使用Demo：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>BlockingCollection&lt;<span style=color:#8be9fd>string</span>&gt; blockCollection = <span style=color:#ff79c6>new</span> BlockingCollection&lt;<span style=color:#8be9fd>string</span>&gt;();
</span></span><span style=display:flex><span>ThreadPool.QueueUserWorkItem(o =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i = <span style=color:#bd93f9>0</span>; i &lt; <span style=color:#bd93f9>200</span>; i++) {
</span></span><span style=display:flex><span>        blockCollection.Add(<span style=color:#f1fa8c>&#34;String&#34;</span> + i);
</span></span><span style=display:flex><span>        Thread.Sleep(<span style=color:#bd93f9>1000</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>ThreadPool.QueueUserWorkItem(o =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>foreach</span> (<span style=color:#8be9fd>var</span> i <span style=color:#ff79c6>in</span> blockCollection.GetConsumingEnumerable()) {
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#f1fa8c>&#34;Read:{0}&#34;</span>, i);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>我们用的是线程池的做法，当然，在并行编程中的做法也是一样的(有做法么？好像没有耶……)。可以看的出，Concurrent相关的结构可以大大简化并行编程中需要考虑的线程安全问题。</p><p>最后要讨论的是.NET 4中很NB的一个东西：PLINQ。并行并行，就是要多CPU协作同时执行，其实有理由相信多CPU可以提高查询的效率(没有说一定是DB查询，不涉及IO性能)，尤其是在内存中集合的查询，PLINQ就是Parallel化的LINQ，使我们的查询可以在多个CPU上同时执行，藉此提高查询效率。</p><p>要想在一个自定义的集合中实现LINQ功能，常用的做法就是实现IEnumerable，这样就可以使用LINQ的查询语法来实现类似SQL的“漂漂”代码，在.NET 4中要想实现一个能并行查询(PLINQ)的自定义集合，可以实现IParallelEnumerable，IParallelEnumerable继承于IEnumerable，实现起来其实也不困难。</p><p>怎样去用PLINQ呢？上一个Demo看看：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#8be9fd>var</span> dataSet = <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>string</span>[] { <span style=color:#f1fa8c>&#34;data1&#34;</span>, <span style=color:#f1fa8c>&#34;data2&#34;</span>, <span style=color:#f1fa8c>&#34;data3&#34;</span>, <span style=color:#f1fa8c>&#34;data4&#34;</span> };
</span></span><span style=display:flex><span><span style=color:#8be9fd>var</span> results = <span style=color:#ff79c6>from</span> d <span style=color:#ff79c6>in</span> dataSet.AsParallel&lt;<span style=color:#8be9fd>string</span>&gt;()
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>let</span> result = d.ToUpper()
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>select</span> result;
</span></span><span style=display:flex><span><span style=color:#ff79c6>foreach</span> (<span style=color:#8be9fd>var</span> r <span style=color:#ff79c6>in</span> results) {
</span></span><span style=display:flex><span>    Console.WriteLine(r);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>只是简单的.AsParallel即可，很好很强大。我们可以使用.AsOrdered来实现在排序前进行缓存。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#8be9fd>var</span> queryByOrder = <span style=color:#ff79c6>from</span> d <span style=color:#ff79c6>in</span> dataSet.AsParallel&lt;<span style=color:#8be9fd>string</span>&gt;().AsOrdered&lt;<span style=color:#8be9fd>string</span>&gt;()
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>orderby</span> d <span style=color:#ff79c6>descending</span>
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>let</span> result = d.ToUpper()
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>select</span> result;
</span></span></code></pre></div><p>这次我们换个方面来将queryByOrder输出：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>queryByOrder.ForAll&lt;<span style=color:#8be9fd>string</span>&gt;(q =&gt; {
</span></span><span style=display:flex><span>    Console.WriteLine(q);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>看来扩展方法这块糖的确很好吃……</p><p>其实在普通的开发中，.AsParallel一下就OK了，我们来猜一下上面代码的结果是怎么样的？答案是不一定有顺序(即使在第二个示例中排序过)，详情请参见上篇中的解释。</p><p>通过两篇文章，我们讨论了一些.NET 4中并于并行开发的基础，在实际的开发中，是否选择并行仍然是一个有待商榷的问题，我们往往关心的是，并行究竟能为开发带来多大的复杂度，能为效率带来多大的提升，下一次我将对并行的效率进行讨论，欢迎大家一起加入。</p></p></div><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//software-story.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></main><footer class=footer><span>&copy; 2022 Lu Rongkai</span>
<span>Made with &#10084;&#65039; using <a target=_blank href=https://github.com/526avijitgupta/gokarna>Gokarna</a></span></footer></body></html>