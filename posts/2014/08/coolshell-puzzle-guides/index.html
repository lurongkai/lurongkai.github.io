<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><style>:root{--accent-color:#FF4D4D}</style><title>coolshell puzzle guides</title><meta name=description content="聊聊软件，聊聊设计，聊聊生活"><meta name=keywords content="blog,lurongkai,Ninja_Lu,software,architecture,Puzzle"><meta property="og:url" content="https://lurongkai.github.io/posts/2014/08/coolshell-puzzle-guides/"><meta property="og:type" content="website"><meta property="og:title" content="coolshell puzzle guides"><meta property="og:description" content="聊聊软件，聊聊设计，聊聊生活"><meta property="og:image" content="/images/avatar.jpeg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="coolshell puzzle guides"><meta name=twitter:description content="聊聊软件，聊聊设计，聊聊生活"><meta property="twitter:domain" content="https://lurongkai.github.io/posts/2014/08/coolshell-puzzle-guides/"><meta property="twitter:url" content="https://lurongkai.github.io/posts/2014/08/coolshell-puzzle-guides/"><meta name=twitter:image content="/images/avatar.jpeg"><link rel=canonical href=https://lurongkai.github.io/posts/2014/08/coolshell-puzzle-guides/><link rel=stylesheet type=text/css href=https://lurongkai.github.io//css/normalize.min.css media=print onload='this.media="all"'><link rel=stylesheet type=text/css href=https://lurongkai.github.io//css/main.css><link disabled id=dark-theme rel=stylesheet href=https://lurongkai.github.io//css/dark.css><script src=https://lurongkai.github.io//js/svg-injector.min.js></script>
<script src=https://lurongkai.github.io//js/feather-icons.min.js></script>
<script src=https://lurongkai.github.io//js/main.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.16/dist/katex.min.css integrity=sha384-6LkG2wmY8FK9E0vU9OOr8UvLwsaqUg9SETfpq4uTCN1agNe8HRdE9ABlk+fVx6gZ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.16/dist/katex.min.js integrity=sha384-31El76TwmbHj4rF9DyLsygbq6xoIobG0W+jqXim+a3dU9W53tdH3A/ngRPxOzzaB crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.16/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script></head><body><script type=text/javascript>setThemeByUserPref()</script><header class=header><nav class=header-nav><div class=avatar><a href=https://lurongkai.github.io/><img src=https://lurongkai.github.io//images/avatar.jpeg alt=avatar></a></div><div class=nav-title><a class=nav-brand href=https://lurongkai.github.io/>程序物语</a></div><div class=nav-links><div class=nav-link><a href=https://lurongkai.github.io/posts/>Posts</a></div><div class=nav-link><a href=https://lurongkai.github.io/tags/>Tags</a></div><div class=nav-link><a href=https://github.com/lurongkai><span data-feather=github></span></a></div><span class=nav-icons-divider></span><div class="nav-link dark-theme-toggle"><a><span id=theme-toggle-icon data-feather=moon></span></a></div><div class=nav-link id=hamburger-menu-toggle><a><span data-feather=menu></span></a></div><ul class="nav-hamburger-list visibility-hidden"><li class=nav-item><a href=https://lurongkai.github.io/posts/>Posts</a></li><li class=nav-item><a href=https://lurongkai.github.io/tags/>Tags</a></li><li class=nav-item><a href=https://github.com/lurongkai><span data-feather=github></span></a></li><li class="nav-item dark-theme-toggle"><a><span id=theme-toggle-icon data-feather=moon></span></a></li></ul></div></nav></header><main id=content><div class="post container"><div class=post-header-section><h1>coolshell puzzle guides</h1><small role=doc-subtitle></small><p class=post-date>八月 5, 2014</p><ul class=post-tags><li class=post-tag><a href=https://lurongkai.github.io/tags/puzzle>Puzzle</a></li></ul></div><div class=post-content><p><p><a href=http://www.coolshell.cn/>CoolShell</a>博主<a href=http://weibo.com/haoel>陈皓</a>做了一个在线的puzzle很有意思，链接在<a href=http://fun.coolshell.cn/>这里</a>，这里记录一下解题的一些步骤。</p><h2 id=puzzle-0>Puzzle 0</h2><pre tabindex=0><code>++++++++[&gt;+&gt;++&gt;+++&gt;++++&gt;+++++&gt;++++++&gt;+++++++&gt;++++++++&gt;+++++++++&gt;++++++++++&gt;+++++++++++&gt;++++++++++++&gt;+++++++++++++&gt;++++++++++++++&gt;+++++++++++++++&gt;++++++++++++++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;-.+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;---.+++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;----.++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+++.---&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;-.+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;---.+++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;---.+++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;--.++&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;.&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;----.++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;---.+++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;----.++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;.
</code></pre><p>如果之前没有听说过变态的编程语言，就让你见识一下。<a href=http://www.muppetlabs.com/~breadbox/bf/>BrainFuck</a>也称BF，是一门只有8个指令构成的图灵完备的语言。CoolShell博主陈皓写过一篇简单的介绍在<a href=http://coolshell.cn/articles/1142.html>这里</a>
具体的指令解释不多说了，直接打长<a href=http://esoteric.sange.fi/brainfuck/impl/interp/i.html>这里</a>，把上面的指令粘进去，运行得到下一关的地址：<code>welcome.html</code>。</p><h2 id=puzzle-welcomehtml>Puzzle welcome.html</h2><pre tabindex=0><code>X * Y
2, 3, 6, 18, 108, ?
What is the meaning of life, the universe and everything?
生命、宇宙以及任何事情的终极答案
</code></pre><p>这题有两个线索，首先是这串数字，其次是<code>生命、宇宙以及任何事情的终极答案</code>。数字序列找规律并不复杂，每个数字是前两个数字之积，那么直接用<code>18 * 108</code>的结果<code>1944</code>尝试进入下一关，发现只找到了一个答案。第二个答案很有意思，或者说很<code>极客</code>很<code>宅</code>，直接google发现和《银河系漫游指南》有关，wiki地址在<a href=http://en.wikipedia.org/wiki/Answer_to_Life,_the_Universe,_and_Everything>这里</a>。</p><p>用<code>1944 * 42</code>的答案<code>81648</code>进入下一关。</p><h2 id=puzzle-81648html>Puzzle 81648.html</h2><pre tabindex=0><code>macb() ? lpcbyu(&amp;gbcq/_\021%ocq\012\0_=w(gbcq)/_dak._=}_ugb_[0q60)s+
</code></pre><p>放眼忘去是<code>Dvorak</code>键盘，点图片可以看到详细信息。那么意图很明显了，<code>Dvorak</code>和<code>QWERTY</code>键盘转换一下看看会怎么样？这里有个在线的<a href=http://wbic16.xedoloh.com/dvorak.html>转换工具</a>，然后：</p><pre tabindex=0><code>main() { printf(&amp;unix[&#34;\021%six\012\0&#34;],(unix)[&#34;have&#34;]+&#34;fun&#34;-0x60);}
</code></pre><p>WTF……搜了一下，这是87年国际C语言混乱大赛的一段代码。C语言了解不多，趁这个机会了解了解戳<a href=http://blog.csdn.net/jishu360/article/details/8104499>这里</a>，还有<a href=http://blog.itpub.net/12443821/viewspace-671745>这里</a>，列一些解此题的关键知识点。</p><h1 id=unix关键字相当于define-unix-1>unix关键字相当于<code>#define unix 1</code></h1><h1 id=数组的引用arraynum和numarray效果相同所以unixhave-等于haveunix结果是aascii是0x61>数组的引用，<code>array[num]</code>和<code>num[array]</code>效果相同，所以(unix)[&ldquo;have&rdquo;] 等于"have"[unix]，结果是<code>a</code>，ASCII是<code>0x61</code></h1><h1 id=0x61--fun---0x60相当于对fun右移0x61指针再左移0x60指针也就是说fun右称一位结果是un><code>0x61 + "fun" - 0x60</code>相当于对<code>fun</code>右移<code>0x61</code>指针再左移<code>0x60</code>指针，也就是说<code>fun</code>右称一位，结果是<code>un</code></h1><h1 id=021是换页于是unix021six0120约为unixnsixn0s被替为前面的ununix再跳过了第一个n所以结果是unix><code>\021</code>是换页，于是<code>&unix["\021%six\012\0"]</code>约为<code>&unix["\n%six\n\0"]</code>，<code>%s</code>被替为前面的<code>un</code>，<code>&unix</code>再跳过了第一个<code>\n</code>，所以结果是<code>unix</code></h1><p>使用<code>unix</code>，进入下一题。</p><h2 id=puzzle-unixhtml>Puzzle unix.html</h2><p>微信扫码，得到：</p><pre tabindex=0><code>[abcdefghijklmnopqrstuvwxyz] &lt;=&gt; [pvwdgazxubqfsnrhocitlkeymj]
</code></pre><p>看来是一个简单的替代，请出大shell</p><pre tabindex=0><code>echo Wxgcg txgcg ui p ixgff, txgcg ui p epm. I gyhgwt mrl lig txg ixgff wrsspnd tr irfkg txui hcrvfgs, nre, hfgpig tcm liunz txg crt13 ra &#34;ixgff&#34; tr gntgc ngyt fgkgf. | tr &#34;pvwdgazxubqfsnrhocitlkeymj&#34; &#34;abcdefghijklmnopqrstuvwxyz&#34;
</code></pre><p>得到：</p><pre tabindex=0><code>Where there is a shell, there is a way. I expect you use the shell command to solve this problem, now, please try using the rot13 of shell to enter next level.
</code></pre><p>这里我脑抽了一下，没看仔细以为是用shell命令，尝试各种<code>tr</code>以及<code>tr xxx xxx</code>都不行，后来出去跑了个步，回来再读一遍发现是用<code>rot13</code>转换一下<code>shell</code>这个字符串，wtf……</p><pre tabindex=0><code>echo &#34;shell&#34; | tr &#34;[A-Za-z]&#34; &#34;[N-ZA-Mn-za-m]&#34;
</code></pre><p>顺利得到下一关地址：<code>furyy</code></p><h3 id=puzzle-furyyhtml>Puzzle furyy.html</h3><p>啊回文，差点一口老血死在这里……</p><p>刚开始思路有点歪，总以为是用<code>cat</code>再加上什么关键字得出一个单词，<code>cat</code>的规律其实已经注意到了，只是在纠结于怎么找到后续字母的规律……妈的走的有点远扯着蛋了。</p><p>后来又是认真读了下揭示语<code>The answer has been lost in the source</code>，咦……</p><p><code>Ctrl + Shift + I</code>打开Chrome的源代码查看工具（IE F12），看见一坨乱码躺在那里，就是它了，很明确，正则表达式。把乱码扔到一个文本文件里，然后执行：</p><pre tabindex=0><code>cat data.txt | grep -E &#34;([A-Z])(\d{1})[a-z](\2)(\1)|(\d{1})([A-Z])[a-z](\6)(\5)&#34; -o
</code></pre><p>输出</p><pre tabindex=0><code>E1v1E
4FaF4
9XrX9
O3i3O
0MaM0
4GbG4
M5l5M
0WeW0
Y0s0Y
</code></pre><p>使用所有中间的字母<code>variables</code>过关。</p><h2 id=puzzle-variableshtml>Puzzle variables.html</h2><p>点图片，进入<a href=http://fun.coolshell.cn/n/2014>http://fun.coolshell.cn/n/2014</a>，显示了一个数字，这时候我脑残的用显示的数据作为answer，显然不行。
看到url里的<code>2014</code>了吗？用网页里的数字替换<code>2014</code>，然后又出现一个新数据，哦原来是这样……接下来就简单多了，上bash脚本。</p><pre tabindex=0><code>#!/bin/bash

baseUrl=&#34;http://fun.coolshell.cn/n&#34;
result=&#34;2014&#34;

while [[ $result -ne &#34;&#34; ]]; do
    result=$(curl -s $baseUrl/$result)
    echo &#34;=&gt; $result&#34;
done
</code></pre><p>输出片断：</p><pre tabindex=0><code>=&gt; 32722
=&gt; 13310
...
=&gt; 16626
=&gt; 20446
=&gt; Cool! the next level is &#34;tree&#34;
run.sh: line 6: [[: Cool! the next level is &#34;tree&#34;: syntax error in expression (error token is &#34;! the next level is &#34;tree&#34;&#34;)
</code></pre><p>虽然脚本不完美，但是没办法，因为不知道最后会输出什么，这样看来搞出error也是不错的选择……使用<code>tree</code>过关。</p><h2 id=puzzle-treehtml>Puzzle tree.html</h2><p>这道题很直白，纯考功底。先还原二叉树，然后找出最深路径，使用此关键字解密字符串<code>U2FsdGVkX1+gxunKbemS2193vhGGQ1Y8pc5gPegMAcg=</code>。</p><p>由于只有中序的后序的遍历序列，所以需要先从后序序列倒着取出根节点，然后再通过中序序列和后序序列来确立左子树和右子树，此过程递归完成。用js写了一段代码来还原二叉树：</p><pre tabindex=0><code>var inOrderSeq   = [&#34;T&#34;, &#34;b&#34;, &#34;H&#34;, &#34;V&#34;, &#34;h&#34;, &#34;3&#34;, &#34;o&#34;, &#34;g&#34;, &#34;P&#34;, &#34;W&#34;, &#34;F&#34;, &#34;L&#34;, &#34;u&#34;, &#34;A&#34;, &#34;f&#34;, &#34;G&#34;, &#34;r&#34;, &#34;m&#34;, &#34;1&#34;, &#34;x&#34;, &#34;J&#34;, &#34;7&#34;, &#34;w&#34;, &#34;e&#34;, &#34;0&#34;, &#34;i&#34;, &#34;Q&#34;, &#34;Y&#34;, &#34;n&#34;, &#34;Z&#34;, &#34;8&#34;, &#34;K&#34;, &#34;v&#34;, &#34;q&#34;, &#34;k&#34;, &#34;9&#34;, &#34;y&#34;, &#34;5&#34;, &#34;C&#34;, &#34;N&#34;, &#34;B&#34;, &#34;D&#34;, &#34;2&#34;, &#34;4&#34;, &#34;U&#34;, &#34;l&#34;, &#34;c&#34;, &#34;p&#34;, &#34;I&#34;, &#34;E&#34;, &#34;M&#34;, &#34;a&#34;, &#34;j&#34;, &#34;6&#34;, &#34;S&#34;, &#34;R&#34;, &#34;O&#34;, &#34;X&#34;, &#34;s&#34;, &#34;d&#34;, &#34;z&#34;, &#34;t&#34;];
var postOrderSeq = [&#34;T&#34;, &#34;V&#34;, &#34;H&#34;, &#34;o&#34;, &#34;3&#34;, &#34;h&#34;, &#34;P&#34;, &#34;g&#34;, &#34;b&#34;, &#34;F&#34;, &#34;f&#34;, &#34;A&#34;, &#34;u&#34;, &#34;m&#34;, &#34;r&#34;, &#34;7&#34;, &#34;J&#34;, &#34;x&#34;, &#34;e&#34;, &#34;w&#34;, &#34;1&#34;, &#34;Y&#34;, &#34;Q&#34;, &#34;i&#34;, &#34;0&#34;, &#34;Z&#34;, &#34;n&#34;, &#34;G&#34;, &#34;L&#34;, &#34;K&#34;, &#34;y&#34;, &#34;9&#34;, &#34;k&#34;, &#34;q&#34;, &#34;v&#34;, &#34;N&#34;, &#34;D&#34;, &#34;B&#34;, &#34;C&#34;, &#34;5&#34;, &#34;4&#34;, &#34;c&#34;, &#34;l&#34;, &#34;U&#34;, &#34;2&#34;, &#34;8&#34;, &#34;E&#34;, &#34;I&#34;, &#34;R&#34;, &#34;S&#34;, &#34;6&#34;, &#34;j&#34;, &#34;d&#34;, &#34;s&#34;, &#34;X&#34;, &#34;O&#34;, &#34;a&#34;, &#34;M&#34;, &#34;p&#34;, &#34;W&#34;, &#34;t&#34;, &#34;z&#34;];

function parseTree(inOrder, postOrder) {
    if (inOrder.length == 0 || postOrder.length == 0) {
        return null;
    }

    var root = postOrder[postOrder.length - 1];
    var inOrderIndex = inOrder.indexOf(root);

    var leftTreeInOrder = inOrder.slice(0, inOrderIndex);
    var leftTreePostOrder = postOrder.slice(0, inOrderIndex);

    var rightTreeInOrder = inOrder.slice(inOrderIndex + 1);
    var rightTreePostOrder = postOrder.slice(inOrderIndex, -1);

    var node = {
        node: root,
        left: parseTree(leftTreeInOrder, leftTreePostOrder),
        right: parseTree(rightTreeInOrder, rightTreePostOrder)
    };

    return node;
}

var tree = parseTree(inOrderSeq, postOrderSeq);
</code></pre><p>OK，树还原出来了，还需要进行最深路径查找脑中瞬间闪出DFS，完全由于<code>深度优先</code>四个字。</p><p>，这个和深度优先搜索有点像但并不是搜索，通过递归的方式得到最长的路径。顺便提一嘴，BFS(广度优先)借助队列实现，DFS(深度优先)借助栈实现。好了，大学课程回忆完毕，上代码：</p><pre tabindex=0><code>function findDeepestPath(selfNode) {
    if (selfNode == null) {
        return [];
    }

    if (selfNode.left == null || selfNode.right == null) {
        return [selfNode];
    }

    var leftPathSeq  = findDeepestPath(selfNode.left);
    var rightPathSeq = findDeepestPath(selfNode.right);

    if (leftPathSeq.length &gt; rightPathSeq.length) {
        return [selfNode].concat(leftPathSeq);
    } else {
        return [selfNode].concat(rightPathSeq);
    }
}
</code></pre><p>得到结果<code>zWp8LGn01wxJ7</code>，保留这个结果，因为下道题还用的到。</p><pre tabindex=0><code>echo U2FsdGVkX1+gxunKbemS2193vhGGQ1Y8pc5gPegMAcg= | openssl enc -aes-128-cbc -a -d -pass pass:zWp8LGn01wxJ7
</code></pre><p><code>nqueens</code>，进入下一题。</p><h2 id=puzzle-nqueenshtml>Puzzle nqueens.html</h2><p>这个倒是简单粗暴，考回溯算法，求解n后，然后暴力穷举出答案。写求n后解。本想用C#写个小程序，然后生成一个带有所有解txt文件，后来想想何必呢，还是继续用js吧，有node呢……</p><pre tabindex=0><code>var crypto = require(&#39;crypto&#39;);
var passwd = &#34;zWp8LGn01wxJ7&#34;;
var target = &#34;e48d316ed573d3273931e19f9ac9f9e6039a4242&#34;;

function writeResult(results) {
    var resultStr = results.map(function (v) {
        return v + 1;
    }).join(&#34;&#34;);

    var hashString = passwd + resultStr + &#34;\n&#34;;
    var sha1 = crypto.createHash(&#39;sha1&#39;);
    sha1.update(hashString)
    var digest = sha1.digest(&#39;hex&#39;) ;
    if(digest == target) {
        console.log(resultStr);
    }
}

function conflict(results, theLocation) {
    for (var row = 0; row &lt; results.length; row++) {
        var queenLoction = results[row];

        if (queenLoction == theLocation) {
            return true;
        }

        var rowDiff = results.length - row;
        var locationDiff = Math.abs(theLocation - queenLoction);

        if (rowDiff == locationDiff) {
            return true;
        }
    }

    return false;
}

function solveQueens(size, results) {
    if (typeof results === &#34;undefined&#34;) { results = []; }
    for (var pos = 0; pos &lt; size; pos++) {
        if (conflict(results, pos)) {
            continue;
        }

        // pos is good.
        var newResults = results.slice(0);
        if (newResults.length == size - 1) {
            newResults.push(pos);
            writeResult(newResults);
        } else {
            newResults.push(pos);
            solveQueens(size, newResults);
        }
    }
}
</code></pre><p>调用<code>solveQueens(9)</code>并在node下运行即可。
最终的代码合并了计算sha1的部分，注意sha1字符串的最后一定要加<code>\n</code>，否则是算不出结果的。
顺利拿到下一关入口``953172864`。</p><h2 id=puzzle-953172864html>Puzzle 953172864.html</h2><p>通过对第一列的观察，发现这是一个26进制/10进制的对应表。那么接下来的总是就是如果将<code>COOLSHELL / SHELL</code>转化为10进制并转换回26进制对应的字母的问题。</p><p>首先COOLSHELL对应的10进制数字分别为<code>3 15 15 12 19 8 5 12 12</code>，计算公式如下：</p><pre tabindex=0><code>3*26^8+15*26^7+15*26^6+12*26^5+19*26^4+8*26^3+5*26^2+12*26^1+12*26^0
</code></pre><p>使用Excel或Google计算结果为<code>751743486376</code>。同理，SHELL结果为<code>8826856</code>。
接下来将两个数相除的结果<code>85165</code>（这个数是带小数，但是因为除数和被除数都是整数所以结果也是整数）转回26进制，即<code>辗转相除法</code>，重复<code>模</code>26并取余数，得到<code>15 25 21 4</code>，对应的字母为<code>DUYO</code>，Bingo进入最后一题。</p><h2 id=puzzle-duyohtml>Puzzle DUYO.html</h2><p>最后一关是最轻松的一关，从图片得出线索是<a href=http://en.wikipedia.org/wiki/Pigpen_cipher>猪圈密码</a>，然后通过一幅简单的图可轻松逆向出答案：<code>helloworld</code>.
ps: 通过图形的形状找图中该图形所对应的字母。</p><p><img src=pigpen_cipher_key.png alt=pigpen_cipher_key></p><p>pps: 昨天答完的时候通过<a href=http://fun.coolshell.cn/top100.html>Top100</a>看到是六十多名，今天再打开发现自己的成绩不见了很奇怪，耗子叔叔我没作弊啊……</p></p></div><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//software-story.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></main><footer class=footer><span>&copy; 2022 Lu Rongkai</span>
<span>Made with &#10084;&#65039; using <a target=_blank href=https://github.com/526avijitgupta/gokarna>Gokarna</a></span></footer></body></html>