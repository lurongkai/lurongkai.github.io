<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>程序物语</title><link>https://lurongkai.github.io/</link><description>Recent content on 程序物语</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 11 Sep 2020 00:00:00 +0800</lastBuildDate><atom:link href="https://lurongkai.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>远程工作是否适合</title><link>https://lurongkai.github.io/posts/2020/09/11/telework-suitable/</link><pubDate>Fri, 11 Sep 2020 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2020/09/11/telework-suitable/</guid><description>远程工作的方式并非适合所有的行业和职位，但是也没有想象中那样遥不可及。对于传统的制造行业，由于地理条件、工厂等客观条件的限制，无法完全采用远程的方式进行协作，这是因为生产本身是信赖于人和固定场地的；然而对于以智力为基础的行业以及职位，完全有采用远程方式的可能，例如软件开发、在线教育、艺术创作、财务和法务等等。
远程工作本身是一种工作方式的实践和探索，没有固定可循的模式。传统的工作方式有着相似的管理和执行方式，只要按照类似的约定就可以让企业运转起来，例如工作时间、工作地点、汇报路径、KPI 等，从一个企业转换到另一个企业不会有太多的不适应，差别也只是很小的细节调整。然而，远程工作方式对企业管理和员工提出了双向的要求，往往需要双方都做出观念上的调整，以适应“远程”所带来的不匹配，这种不匹配是新的工作方式和传统方式不一致而造成的恐慌和落差。
这需要更多的相互信任和探索。
2020 年以来，针对远程工作的讨论逐渐变多，集中在管理、方式方法、优劣势上，其中对传统的管理方式提出的挑战更多，这是由于远程的方式对以公司为代表的管理方带来了不确定性。同时，由于方法学层面的缺失，致使一大批不得已在疫情期间采取远程办公的企业，深深的感受到了什么叫做“车祸现场”。
解决了管理层面的问题，公司才敢远程；解决了方法层面的困惑，雇员才能远程。
换句话讲，行业的运作方式决定了远程是否可以有落地的条件，企业管理层面是否可以改变和创新决定了远程工作方式是否可以有效展开，而雇员是否能高效的进行远程协作（工作方法）将会是远程工作的最后一公里。这其中的每个环节都是不可或缺的，否则很难说一家采用“远程”工作方式的企业却没有成功展开工作，是由于远程本身出了问题，还是企业的管理没有跟上，亦或是雇员自身的问题。
总之，这是一个需要综合考量的问题，草率的对一个行业下是否适合远程的结论是不合时宜的。远程工作的理念不是很新，但是实践中的指导方式却很有限，所以，这是不断探索的过程。
期待有更多的行业发出声音，分享各自的实践经验，也期待已经在践行远程工作的劳动者分享有效的工作方式，共建社区。</description></item><item><title>我与盛安德的 10 年</title><link>https://lurongkai.github.io/posts/2020/08/03/shinetech-decade/</link><pubDate>Mon, 03 Aug 2020 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2020/08/03/shinetech-decade/</guid><description>引子 2011 年的一个上午，在工作一个星期后，我离开了毕业后第一份工作。然后用当周的薪水买了一台显示器和十几本书，决定闭关修炼一个月。后来的事实证明，显示器只有在玩游戏和刷剧时才能发挥最大的功效，而书虽然会给搬家增加负担，但好歹是不错的投资。
当时的事业部负责人才签字时，流露出一种“刚毕业的小白竟然敢如此造作”的狐疑表情，问我为啥离开？我说不适合公司文化。
事实上，小组里的人都在加班，但即便自己没有任何的开发任务，却被要求“陪着”加班……加班费正常给、管餐、打车报销，除了不能上网（物理上）、USB 全封、禁止带书和 kindle……能做的只有玩手机，以及玩没电后睡觉，迷之文化。
我决定，下一份工作一定得找个文化上比较 open 的公司。
初识 在昏天黑地的刷了 N 部剧后，我决定开始找找新机会。刚好在博客园上注意到盛安德在天津招 5 年经验的高级软件工程师，抱着“我脸皮厚我怕谁”的态度投了唯一一份简历，没想到就收到了面试邀约。
整个过程就很奇妙，和@Russel 聊了两个多小时，已经想不起聊了些啥，反正就知道河西分公司刚成立，办公室新租的，桌子是刚买的，人呢就@Russel 自己……
于是你哈哈哈我哈哈哈，聊的很开心的一周后，我成为了 Shinetech 天津河西分公司的 03 号员工，02 号是@温融晶。
小项目 一切从最简单的项目开始。我们做了几个规模相对小一些的小项目，最终都成功交付。当然了，对于我而言，最为重要的是，终于弄清楚了公司的主营业务是什么，以及管理架构是什么样的……
这非常奇妙，就是一切的关注点都在项目和交付上。我当时最大的困惑就是，这公司到底有多少人……真的不是皮包公司吗？
陆续的，有更多的小伙伴加入了进来，我同校的学长@Nick，和我简直不要太对脾气@Jaime（我们经常起个头就知道接下来要说什么、优缺点是什么）……这下放心了，应该不是骗子公司:-P。他们加入后，技术氛围就更加浓烈了。后来@Vivian 也和我们在同一个办公室工作，大家有说有笑，气氛非常好。
说到这里，还有点想@Jaime 了。
Ralph Lauren 12 年的时候，@Russel、@温融晶和我三个人前往美国 Texas，着手 Ralph Lauren 的项目，这是我加入 Shinetech 后真正意义上的大项目，我们在 Austin 停留了近两个月了解和参与业务，为接下来的两年工作打下了基础。
那一段日子可谓是异常的潇洒，白天忙碌，晚上看看资料或者压压马路，到了周六日就在一起打打游戏，Diablo II、CS、Red Alert 全部复习了一遍。不工作的时候，最费脑子的就是去哪家餐馆吃饭的问题。期间去当地的景点玩，进去后才发现是类似于我们爱国主义教育基地的地方，回忆起来也是颇为有趣。
回国后项目正式开始，@Russel 在项目上投入了极大的精力，正是他的不懈努力，这个项目逐渐成为公司的明星项目。一年后，客户来上海审查我们的项目，我被任命为这个项目的 Technical Leader，这是在技术能力上得到了认可，非常开心。
两年后，我想要换换思路，决定暂时先别这个项目，同一时间，@Robert 加入了公司，是个去吃自助大餐要先来碗白饭的神人，非常有意思。
几年的工作很充实，但是却几乎没有加班过。其实实践不加班是很难的，但是 Shinetech 在这一点上践行的很彻底，值得尊敬。
(Ralph Lauren 团队在上海)
看看世界 15 年的时候，生活和工作趋于过分的平静，我感到这是个危险的信号，所以我决定给自己点时间去外面的世界看看。其实我一直很感谢@Russel 的赏识，他建议我去北上广历练一番，于是还是老规矩，休息一个月，然后在北京投了两个相对高阶的职位。
都是移动互联网公司，一家 B 轮，一家天使轮，考虑了一下去了天使轮的公司。倒不是因为给期权，而是感觉可以做更多的事情。
传统软件公司的思路和互联网公司的思路真是完全不同，前者做事稳妥但是缺乏创新和敏捷（虽然口号是敏捷），后者行事快速果断但是大多只追求了速度，基础设施薄弱。
这一年积累和认识了颇多，更多的是包容。没有完美的方案，只有在成本范围内适合的方案，这也是最为刻骨铭心的架构准则。
我带来的是对整个技术团队基础设施和技术栈的升级，同时重构协作文化（没错，导入了敏捷开发）。而回馈给我的，是互联网公司更加自驱动的做事文化，这在传统软件公司是极度欠缺的。</description></item><item><title>介绍 Shinetech Open Community</title><link>https://lurongkai.github.io/posts/2020/04/01/soc-intro/</link><pubDate>Wed, 01 Apr 2020 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2020/04/01/soc-intro/</guid><description>Shinetech Open Community（以下简称SOC）是盛安德公司内自发组织的一个松散组织团体，吸纳和整合公司范围内优质资源，包括但不仅限于研发工程师及业务分析、工程管理等各方面的明星同事，力图打造新的 Shinetech 子品牌。
自成立 3 个月以来，SOC 以极其迅速的姿态组织和发起了多项品牌衍伸项目，得到了公司内的良好反馈，我们坚信做这件事情所带来的不菲的价值，也定会坚持把 SOC 发展下去。
为什么成立 SOC SOC 的萌芽是在天津交付中心，一次闲聊时我们一致认为，Shinetech 值得拥有更好的工程师工具，以及面向整个开发者社区更好的技术形象。于是，我们决定组织成立一个松散的团队，用自己的力量改善这些状况。
SOC 起初并没有明确的目标的方向，除了Open Source这个选项之外，能做的似乎非常有限，连正式的组织名也没有确定。现在我们意识到这也是任何想“搞点事情”的组织所面对的共同疑问。于是，我们召开了一次非正式的线下聚会，希望通过有效的头脑风暴，确定组织的发展方向和计划。
时值经理正好开完 3 月份的全员例会，提到了一些ORK的理念，我们也针对性的了解了一些ORK的优劣势，认为这可能是值得在组织内采用的一套目标管理工具。
在通过广泛的讨论之后，我们确立了组织运作的形式的方向，成立了Shinetech Open Community，并决定在形象建设、宣传推广、开源项目、工具和分享这四个方向上努力。
SOC 的目标和使命 SOC 的初期ORK非常简单和明确，只有 4 个大O，下面分别有着不同的KR
以开放合作的姿态建立 shinetech 新形象 用富有成效的软件工程实践提升工程师的基础能力 为工程师提供更为实用的研发工具和工作平台 提升个人品牌价值，从而互相提升 Shinetech 品牌价值 我们阶段性的目标，是希望通过不断的努力，将 Shinetech 这个品牌，拓展为另一个从工程师文化层面能够足够吸引优秀人才的平台，让更多的人不仅仅是通过 Shinetech 的交付能力而关注公司。同时，通过 SOC 一系列的产出，让公司内的同事能够受益，进而提升个人品牌价值，让 Shinetech 的品牌价值更具竞争力。
SOC 带着愿景成立，通过三个月的运作，我们相信下面的 slogan 足以涵盖 SOC 正在践行的使命:
Be Share Be Open Be Shinetech
SOC 的工作方式 SOC 通过自管理的方式运作，我们自己戏称为“一个敏捷并自我驱动的松散管理的非正式组织”。虽然松散，但是我们仍然有一套基本的工作方式。
我们每周会定期的召开weekly meeting，回顾过去一周所做的工作，并制定本周的工作安排，也会讨论未来将要展开的计划。由于 SOC 成员本身有可能在项目中，所以会议不是强制的，这也是“松散”一词的由来。</description></item><item><title>如何优雅的在 Golang 中进行错误处理</title><link>https://lurongkai.github.io/posts/2019/07/handle-error-graceful-in-golang/</link><pubDate>Fri, 26 Jul 2019 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2019/07/handle-error-graceful-in-golang/</guid><description>&lt;p>如何优雅的在&lt;code>Golang&lt;/code>中进行错误处理？&lt;/p>
&lt;p>答案是：没有……（本文完）&lt;/p>
&lt;hr>
&lt;p>开个玩笑，&lt;code>Golang&lt;/code>中的错误处理方式一直是社区热烈讨论的话题，有力挺者，有抱怨者，但不论如何，自 2009 年&lt;code>Golang&lt;/code>正式发布以来，关于错误处理就一直是现在这种状况。&lt;/p>
&lt;p>随着&lt;code>Golang&lt;/code>愈加的火爆，原本是&lt;code>Java&lt;/code>、&lt;code>Node&lt;/code>、&lt;code>C#&lt;/code>等语言擅长的应用级开发领域也逐渐出现&lt;code>Golang&lt;/code>的身影。&lt;code>Golang&lt;/code>自身其实更加擅长做基础设施级开发，例如&lt;code>docker&lt;/code>，例如&lt;code>k8s&lt;/code>，再如&lt;code>etcd&lt;/code>，它友好的内存管理和简单到粗暴的语法（25 个关键字），特别适合过去&lt;code>C&lt;/code>和&lt;code>C++&lt;/code>这些语言所擅长的部分场景。我们有理由相信，&lt;code>Golang&lt;/code>下一个大的引爆点将也许会在&lt;code>IoT&lt;/code>上，因为它天然的适合。&lt;/p>
&lt;p>当一门语言火起来，就会出现各式各样的应用，于是&lt;code>MVC&lt;/code>框架有了，音视频处理库有了，各种数据库驱动有了，甚至服务框架也出现了，游戏、&lt;code>Machine Learning&lt;/code>都不在话下，还要啥自行车？组合一下做应用级开发妥妥的没毛病。&lt;/p>
&lt;p>但是，成也这 25 个关键字，败也这 25 个关键字，究其根本原因，都是因为它背后&lt;strong>简单&lt;/strong>的哲学。&lt;/p>
&lt;p>做应用级开发可不是那么简单的，这涉及到很多的细节处理，例如本文将要讨论的错误处理。如果只是写一个库，那么这个话题相对比较简单，因为与&lt;code>API&lt;/code>打交道的都是开发者，你只管开心的往外扔&lt;code>error&lt;/code>就好了，总会有倒霉的程序员在使用你的代码时&lt;strong>DEBUG&lt;/strong>到白头，最后，以最严谨的方式，小心使用你的库；可是有人出现的地方就会有幺蛾子，一个常见的误区就是将&lt;strong>业务错误&lt;/strong>、&lt;strong>运行时错误&lt;/strong>、&lt;strong>程序错误&lt;/strong>一股脑的当成相同的&lt;code>error&lt;/code>来处理。&lt;/p></description></item><item><title>关注软件开发中的安全</title><link>https://lurongkai.github.io/posts/2019/02/15/shinetech-2018-security-training-summary/</link><pubDate>Tue, 05 Feb 2019 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2019/02/15/shinetech-2018-security-training-summary/</guid><description>&lt;p>18 年 10 月底的时候，我在 Shinetech Software 内部做了一场在线的培训，主要关注的是在软件开发过程中，对于安全方面的工程实践，并不算是很深入的探讨，更多的是一些极不易察觉但又很常见的疏忽，这篇博客整理出来。&lt;/p></description></item><item><title>理性沟通的团队</title><link>https://lurongkai.github.io/posts/2017/03/02/retional-team-with-communication/</link><pubDate>Thu, 02 Mar 2017 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2017/03/02/retional-team-with-communication/</guid><description>部分整理自Shinetech 2016-10-19内部分享）
《敏捷软件开发宣言》 我们一直在实践中探寻更好的软件开发方法，身体力行的同时也帮助他人。由此我们建立了如下价值观：
个体和互动 高于 流程和工具 工作的软件 高于 详尽的文档 客户合作 高于 合同谈判 响应变化 高于 遵循计划
也就是说，尽管右项有其价值，我们更重视左项的价值。
小而精的团队，往往更具有战斗力。我们提倡敏捷，也愿意相信它的价值，然而敏捷的实践却不仅仅是清晨站会、打打估算扑克那么简单。在我看来，其中最容易被忽视的一句便是：尽管右项有其价值，我们更重视左项的价值。如果一个开发者不写文档的理由是“我敏捷”，这就大错特错了，我所理解的敏捷，是关于『沟通』和『协作』的方式。
沟通自然重要，信息在传递中存在损失的可能，所以提倡尽可能的与客户直接沟通获取一手信息，避免经手N个人才到最终的实施者。同样的，部分信息也需要共享给团队成员或者stakeholder，由于沟通存在成本，所以方式方法亦很重要。
团队也需要协作，看板驱动带来潜在的负面影响就是每个人只关注用例，对项目整体的看法缺失，成员间的协作变少，由此在整个项目上出现了不同的视角。短期内任务是完成了，长远看分裂会逐渐积累。
敏捷是关于一个团队整体的态度，那么什么样的态度对团队是有益的呢？我们不妨审视一下以Github为代表的开源开发方式，并引入多种可用的工具，看能不能从中受到一些启发。
信息的推送与管理 程序员不喜欢邮件，认为邮件是浪费生命。无缘无故的被加入到邮件列表中，看着大家开始扯皮，扯到最后发现和自己没有一分钱关系，尴尬的是不看又不确定和自己有没有关系。又或者突然转发给自己了一封邮件，打开里面长长的对话，读了很久才知道说了什么。
这里的问题在于，邮件并不适合归档和提取信息，并且是强干扰因素。不妨回想一下，有没有参与这样一种项目，就是全程没有文档，进入项目组的当天转给你N封邮件让你读？再或者，连看板工具也没有，大家通过一个excel文件，标成黄色背景的你做，标成绿色背景的我做，彼此通过邮件来发送这个excel文件？
换一种思路，如果没有邮件，我们如何沟通？
Github有个非常好用的工具：Issues，任何人有问题、建议、计划等都会在里面建条目，然后完善Issue的详情并且展开讨论。上千人协作的项目用它用的不亦乐乎，这里的关键在于，信息完全是公开的，任何人都可以讨论，每个人只在必要的时候介入。同时，信息的噪音也很小。
这也是为什么Github被称为社交化编程。形象的打个比方，邮件好比写博客打架，你写一篇我写一篇，观点被不断放大，而Issue为基础的工作流则更像是Twitter，我说『filtering()方法出错了，报null异常』，下面有人回复『L30的null检查没有做，@Javis 请看一下』。
接下来，对PM来说，看来这个优先级比较高，马上打了个critical的标签，然后放在了current-milestone并分配给了@Javis，即刻，@Javis的上桌面上收到了通知，1分钟改好后提交了。
由于故事本身被限制在了一个很小的Item中，每个人可以更加关注于其本身。如果需要引入类似看板的功能，推荐大家试用ZenHub扩展。
另外，诸如Teambition, Tower, Trello这样的工具也可以提供灵活的任务管理，将一个大的用例切成小的部分，针对每个部分单独讨论，可以降低沟通成本，并且为归档提供了更多参考，不过，这些工具更倾向于客户与开发团队间针对需求和进度的沟通。
如果只是开发团队内的沟通，Github Issues, Jira, Redmine这些耳熟能详的缺陷跟踪工具一定可以帮助团队，让信息更加的透明，尽可能的减少信息干扰，降低沟通的成本。
随时共享你的想法 任务管理，或者缺陷跟踪的本质，是为了让信息便于管理和推送，同时带来一个新的挑战就是信息的归档。有很多的任务，其下对应的讨论是很有价值的，如果整个Item都是有限定的在讨论，那么从中提取信息就会变得容易。更进一步，可以将用例的讨论变成使用手册吗？可以将针对某个具体技术点的讨论变成团队共享的知识库吗？
知识库是全团队受益的，虽然敏捷认为文档的优先级不是最高的，但是绝不是说它不重要。对于程序员来说，有时候并不是不愿意写文档，而是写文档的工具不好用。
从Github得到的安利，就是好用的wikis工具，你值得拥有。结构化的文档体系，不需要安装任何软件就能写，每个人都能编辑完善，告别word和excel。
PM和开发人员应该对产生的Issues（或者叫Task）保持敏感，随时准备好提取和分享这些知识。而Email驱动的工作流养成的坏习惯，就是当需要将一些信息提供给他人时，不做任何修饰的把邮件列表转发出去。
当引入Issues（Task）驱动的工作流时，在它结束或close的时候，是最好的审视时机，回顾一遍，看有没有什么能共享的可以尝试归纳整理，分享是会上瘾的。
这件事，还有个非常著名的名词，叫做『知识传递』。
怕花钱？怕信息泄露？不妨试试Gollum（Github的wikis也是用它），其它的任务管理、缺陷管理工具也大部分也都提供wikis工具（例如Redmine, Jira），一朝架设终身受益啊。
非正式的沟通 有时候面对面的沟通，或者电话会议是无法避免的。任务管理工具也有自身的短板，就是不适合讨论非常复杂的问题。
Skype在语音方面的表现相当的好而且免费，但是作为一个消息工具，它的确显得不怎么好用，或许在与客户沟通时使用Skype已经足够了，但是对程序员来说，频繁的分享代码片断，或者在群聊中@某个人时，它的表现并不抢眼，想加粗某段话都不支持。
QQ，微信，更不用说，只聊天还行，协作并不是他们所擅长的。
程序员需要更好的交流工具，尤其是文字的。如果已经使用了Github Issues，就会发现，@某个人，或者链接某段代码非常方便，再者，贴出的代码带有语法高亮让人看着非常舒服，毕竟，程序员之间经常说“黑话”，一段没有高亮并且不是等宽字体的代码非常跌份儿。诚然，Issues作为非正式的沟通工具还是显得太不正式了……
不如，试试火爆全球的Slack？基于轻量级的Channel（可以想像成一个随意进出的微信群）可以快速拉几个人进行讨论某个Subject，丰富的ref功能可以随意的@人和链接一切，尤为重要的，就是它支持Markdown，而且它足够的轻量，相信试用一下就会爱上它的。
这并不是故事的全部，最有杀伤力的一点，它可以集成进任何的系统，持续集成、持续部署、运维监测、自动化机器人，比如@WallE deploy production，就会触发部署消息传递到你的运维系统开始部署，试试吧。
当然了，国外有的中国就早晚会有，就像twitter和微博……国内的『简聊』（Teambition团队做的）做的也非常不错，功能类似，推荐一试。
善用VCS工具 Github带来的另一个启迪，就是关于源代码管理的方式。众多的VCS工具，从TFS到svn，从Mercurial到git，无疑给了我们太多的选择，用好哪一个都会带来极大的生产力提高，然而事实并不如此。
很多的团队，仍认为VCS就是个存代码的地方，这或多或少的会给流程带来一定的影响。Github提供的思路很独特，在git的基础上创新的提供了pull request工作流。我们都确信code review带来的价值，我们也认同unit testing为QA带来的红利，但事实上做的人很少，有流程和其它的原因，当然也有工具不够好用的原因。
而pull request这种方式为我们提供了一种思路。善用工具，就得理解工具背后的文化，比如从svn迁移到git，就不应该在同一个分支上死签入到底了。从任务管理或缺陷管理工具开始一个新的任务，马上新开一个分支，不断的提交与实现，当完成时发起pull request让团队内的其它人来review是一种很好的知识传递的方式，同时，在pull request的窗口期内也可以不断的改善，确保最终的合并是一种完整的合并，这种一致化的体验在其它的VCS系统中是很难做到的。
相信工具的力量，架个git试试吧，别用svn了，比如试试Gitlab, Gogs，或者用在线的coding.</description></item><item><title>软件与设计</title><link>https://lurongkai.github.io/posts/2016/01/17/software-and-design/</link><pubDate>Sun, 17 Jan 2016 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2016/01/17/software-and-design/</guid><description>我曾经面试过一个有10年工作经验的“.NET架构师”，也就是说比我年长很多的前辈，当时还挺不安的，但是当我拿到HR转给我的简历时，心里却犯起了嘀咕：这简历，能不能做的整齐一些？至少，每个段落的文本可不可以对齐？难道……
顺利的按约定好的时间见面，聊起来发现原来还是半个老乡。我并没有准备什么面试的内容，而是对照简历和他细聊，因为我相信，优秀的工程师拥有的是解决问题的能力，所以我愿意按对方了解的东西去发现，或者说在中途放置一个小路障看对方如何解决。
当看到有丰富的优化经验时，我了解到之前的项目做了很多静态化的工作，于是我开始下绊子：为什么要考虑静态化？回答还是中规中矩的，比如访问慢啦、经常503啦。我灵机一动：你们是如何发现这个问题的？大哥抬头一脸疑惑的打量着我这个小后生：因为服务器上硬盘灯狂闪啊！当时我就草泥马奔腾了：你们都特么不用Profiler么……
我于是放下了他“架构师”的头衔，开始问他作为一个.NET工程师最基础的：什么是Lambda表达式？和委托有什么不同？（其实完全就是一回事，我在故弄玄虚），大哥又开始迷茫了，内心好像在说：草泥马C#还有这东西？于是礼貌的告诉他会有人通知他面试结果的。之后大哥以半老乡的身份曾打电话给我跟我说：你要不帮我再说说好话？我说好的……
当年的这场面试在我幼小的心灵留下了阴影，我突然发现这行业里的水还是深的。而随着时间的流逝面试了更多的人后，我习惯了……
我对软件开发是抱有一种尊敬的态度的，它应该是美的、理性的。和你一起战斗的同事可以有鲜明的个性，也可以以任何邋遢的形像出现，但是终归到底，对待自己写出的东西要起码抱有一丝负责的态度。允许写出的软件不漂亮，但是既不漂亮也不想办法改善就是你的不对了，盖楼的偷工减料害的是人命，软件偷梁换柱虽然不致命，但是这事儿谋财啊亲！！
什么是态度？或者说什么是优秀工程师的态度？
对待软件的态度 软件是要给人用的，是一种服务产品，所以我们从事的是服务行业。假如我们是厨子，做出的菜里有头发这事儿能忍吗？请摸着你的胸想想……
有点弄不太懂的是，有一大批工程师正在仰天长叹：“小bug不用修、小细节不用在意，只要产品能上线！”，真特么闹心，工程师操产品经理的心，产品经理操投资人的心。赚的卖白菜的钱操的卖白粉心，长此下去要亡国的呀！（友情提示，操字请读一声）
能不能认真点？能不能走点心？小细节问题还能饶一条小命，bug简直应该鞭尸，为什么有bug却不改？都不写测试吗？
每个工程师可以不完美也允许不完美，可以有缺陷，但是得有态度，这种态度就是对不完美的不断修正，是情怀。一个面对不完美，却完全不动容的工程师那绝B是个好销售。如果连工程师们都不去修正不完美，那这工程或项目可以洗洗睡了。
作为工程师，编写代码时要时刻提醒自己：我打算让全世界的工程师来看我的代码！这样一来，你便不好意思使用过多的Magic Number，不会在一个方法内写一坨屎一般的嵌套if，因为这样很害羞，有种扒光了被弹小鸡鸡的耻辱感！随着对代码下手越来越慎重，质量也会逐步提高，当你老了的时候也不会拉着孙子的手忏悔过去：爷爷当年犯过大错，写了很多超过1000行代码的函数……
我甚至有时候觉得，人就是得被收拾才行，Linus在邮件列表狂喷时，我每次都是心里叫好，然后对别人说：Linus说话还是太冲动，Too Naive。每当团队内的成员有写出翔码时，我都是以一种衣冠禽兽的面目出现：xx啊，这段代码我看着有些吃力，应该有更好的办法，你能想办法重构一下吗？然后自己默默念《清心咒》10遍以克制体内的洪荒之力爆发……
软件，应该视为脑力的结晶，工程师们应该不希望别人说这结晶长的像翔吧？要知道这可是脑力的结晶……
对待开发的态度 软件是复杂的，编写质量优秀的软件不是件容易的事儿。现代的软件或者叫应用已经越来越复杂和庞大，单枪匹马撸出个软件的事儿也越来越不现实，经常需要很多人共同的参与才能将事情做好。
不谈浮躁的环境，单从开发本身来讲，这就是一件严肃的事儿。有的工程师在遇到问题时，马上google解决方案然后copy/paste过来以期望马上可以使用，没有思考没有考虑是否会对现有的设计造成影响。不断的尝试google不断的重复，心塞的工程师们总结出这门语言/平台不适合做这件事，还是原来用过的东西好……之后论坛掀起又一波语言圣战。
对待开发，究竟是什么态度？
经常有工程师抱怨：
项目进度很紧，根本来不及停下来反思 copy/paste能马上解决的事儿，干嘛要提取出共性的东西 我先临时对付一下，回头再来改 墨菲法则告诉我们，越担心的事情就越会发生，如果不一步一步的踏实前进，将来清理技术债务的成本将远大于投机取巧带来的短期收益。我大中华也有类似的谚语：偷鸡不成把蚀一把米。
不要有技术债务，不要抱有幻想，尽可能的将自己在做的事情做到极致，不给其它同事带来困扰，冷静的思考，这是开发应有的态度。
对待技术的态度 不管你承认与否，每门技术或语言的表达能力都是相同的，所以不要幻想我在使用的东西别的技术做不了，大家都是图灵完备的。这同时告诉我们，做.NET的不要看不起做Java的，做Java的不要看不起搞Ruby的，各有所长，以诚相待。
但是还有一个重要事实，就是每种技术侧重的场景是不一样的，SQL侧重数据的查询，RoR侧重快速开发，Node侧重高IO场景……大家都有自己的看家本领，没必要非要用一种技术统一天下，这不现实。
几乎所有的技术社区，每过一段时间就会出现唱衰某种技术的帖子，绝大部分并不是从技术本身分析，而是从自身出发，发现自己使用的某项技术赚钱太少，吵吵着要转型。何必呢，用筷子的没必要看不起用刀叉的，况且自己筷子也没怎么用好。搞技术嘛，就不要像娱乐圈那么乱了，天天撕有什么意思呢，有本事出去打一架……
面对层出不穷的新技术，我觉得一个优秀的工程师并不会排斥了解它们，而且一个有能力的工程师能够结合自己的经验快速的学习，当作自己的知识储备。从我个人角度来看，应该有三个视角用来审视一门新技术：
What: 这门技术是什么？它用来解决什么样的问题？
Why: 这门技术为什么会出现？在它出现以前是什么解决的？它能更好的解决吗？
When: 这门技术在什么状态（上下文）下发挥作用？有什么限制条件？ 举个例子，对TypeScript的审视：
What: 是javascript的超集，并添加了一些关键特性用于支持大规模的javascript应用开发，用来解决在应用规模变大时，javascript组织应用程序变的困难的痛点。
Why: javascript并没有包、类的概念，所以难于组织大规模应用，在这之前有CoffeeScript，或者纯靠人力。TypeScript更友好一些是因为它并非像CoffeeScript创造一门新语言，而是在现有javascript的基础上无痛的升级，并且编译成javascript来用，所以兼容性是完全保障的。
When: 几乎所有的javascript开发都可以使用TypeScript来做，借助静态类型系统甚至可以提供智能提示以提高开发效率，并同时避免错误拼写。限制条件是，如果想要获得完整的静态类型系统，需要针对现有的库编写definition文件，然而最怀的情况也就是在编写普通的javascript。 冷静的对待每一门技术，让他服务于人，而不要将事情反过来，这是对技术应有的态度。
对待设计的态度 没有设计的软件是可耻的。这里的设计是指软件本身的设计、结构，并不涉及UI/UX。
有非常多的优秀书籍在讨论如何设计软件，但似乎读的人很少。冲动的工程师们读过Gof23就想在每个项目里挨个试一遍，说用过MVC却在Controller里写所有的业务逻辑，一说架构就是三层架构……这个路子有点太飘逸，打法不对。
我认为的设计有两方面：架构设计和代码设计。
架构设计就是指在高层上对一个软件工作方式的约定，比如服务层设计、读写分离等，这些是架构设计，往往是架构师们做出的决策。
代码设计是工程师们更多接触到的，比如一个方法/类的实现，一组API的设计等等，与每个人日常相关。
我见到过很多遗留代码里N多的静态类和伪静态类（意思是，虽然不是静态类，但是用起来和静态类没什么不同），最牛逼的是有个大哥一进项目先不问项目的情况，而是直接拷贝了一个Helper工程（对，是上百个源文件，不是dll）并提交，里面五花八门什么都有，感觉能创造出一个宇宙的那种。还有的工程师一进项目第一件事，先让Presentation工程引用Persistence工程，说什么访问数据还得从服务层绕一下，不方便……
我一直孜孜不倦的在内部普及一些基础的设计概念，讲什么是SoC、LSP、SRP、OCP、DIP、ISP，什么是DI，有什么优点以及为什么等等，效果还是很明显的，至少在面对需求的变化时，大家发现好的设计可以灵活很多，没以前那么痛苦了。</description></item><item><title>函数式编程中的常用技巧</title><link>https://lurongkai.github.io/posts/2015/11/24/functional-programming-skills/</link><pubDate>Tue, 24 Nov 2015 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2015/11/24/functional-programming-skills/</guid><description>&lt;p>在 Clojure、Haskell、Python、Ruby 这些语言越来越流行的今天，我们撇开其在数学纯度性上的不同，单从它们都拥有&lt;code>一类函数&lt;/code>特性来讲，讨论函数式编程也显得很有意义。&lt;/p>
&lt;p>一类函数为函数式编程打下了基础，虽然这并不能表示可以完整发挥函数式编程的优势，但是如果能掌握一些基础的函数式编程技巧，那么仍将对并行编程、声明性编程以及测试等方面提供新的思路。&lt;/p>
&lt;p>很多开发者都有听过函数式编程，但更多是抱怨它太难，太碾压智商。的确，函数式编程中很多的概念理解起来都有一定的难度，最著名的莫过于[单子](&lt;a href="https://en.wikipedia.org/wiki/Monad_(functional_programming)">https://en.wikipedia.org/wiki/Monad_(functional_programming)&lt;/a>，但是通过一定的学习和实践会发现，函数式编程能让你站在一个更高的角度思考问题，并在某种层面上提升效率甚至是性能。我们都知道飞机比汽车难开，但是开飞机却明显比开汽车快，高学习成本的东西解决的大部分是高回报的需求，这不敢说是定论，但从实践来看这句话基本也正确。&lt;/p></description></item><item><title>提高工作效率与幸福度-工具篇</title><link>https://lurongkai.github.io/posts/2015/10/14/improve-work-efficiency-and-happiness-2/</link><pubDate>Wed, 14 Oct 2015 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2015/10/14/improve-work-efficiency-and-happiness-2/</guid><description>这篇文章略难产，事实上距离”基本篇”的发布已然过去了小半年了，生孩子生到这份儿上也真是够够的了。那时天还是辣么蓝，微风徐徐鸟语花香，我独自抚摸着猫在键盘上激情的写作……后来，把下篇给忘了。据说刨坑不填的都得拉去烧死，我想了想觉得挺疼的，所以抓紧补上吧。
先回顾一下基本篇阐述的基本事实：
邮件 is bitch 电话有时让对方不爽 信息的组织与提取不是容易的事情 对于这几个bitch上篇给出了简单的建议，不妨作为一种过渡手段，但是身为现代人类，有辣么多好用而且几乎都是免费的工具可以使用，why not? 不过说到底，再牛逼的工具也不能解决人懒惰的问题，工具只能让你更好的做事，不能帮你做事，躺着就把钱赚了的事不多，要想清楚。
改善沟通 Teambition 如果你的团队或当前项目是10-30人左右，我建议尝试一下免费好用的Teambition，类似的产品还有Worktile和RedBooth。
Teambition基于任务板来分割任务，并且可以设置任务分组，当项目的构成需要复杂的人力协作时，将其分割成不同的小任务（或子任务）并分配给相应的责任人，然后同时设定任务阶段，所有的进展情况与信息一目了然，对于建立团队信心也有着积极的作用。
如果你使用微博或者Twitter，可以使用@符号来提醒相应的人介入讨论，这里的好处在于：
所有的讨论都在一个任务下，不会出现信息分裂 信息可检索，包括讨论的内容、附件等 只有需要某个同事介入时他才会得到通知 对比邮件：
一件事或任务往往分散在各个不同邮件内容里，东拉一句西扯一句，谁知道扯的什么蛋 要找到有关某件事的信息，需要查找所有的邮件内容，有时还需要人工阅读整封邮件 跟我有没有关系都CC我，我特么真的会看么？不看真特么可以么？ 基于任务的管理，可以一目了然的看到项目反馈，为项目计划提供数据参考。 Calendar Outlook有一项极其好用的武器叫Calendar，我知道很多成熟的企业其实是高度使用Calendar的，但是如果你的团队没有使用过，我建议你尝试一下。
Calendar可以定制团队日历，不要把它单纯的当做预定会议室的工具，它能做的还有很多。设置团队Deadline，Meeting计划等等。
将个人的事宜纳入Calendar也可以收获良多，比如”15:00 - 17:00 处理A任务”，”Jun 23 联系客户X确认数据”。不要把自己逼太累，有工具不用当自己是闹钟啊？
当然，如果你已经采用了Teambition，还是建议使用它自带的Calendar，毕竟和Teambition集成度更高，使用起来也更为方便，你可以得到所有Outlook Calendar提供的有用功能。
提高信息利用率 可以肯定的是，大部分的企业并没有定期整理信息的企业文化。在软件开发领域，定期整理文档是一项历史悠久然而并没多少人践行的神话。
企业虽不强求，但是如果你是一个PM，推荐你建立这种团队文化，这会让你受益良多。
下面两个工具，evernote是个人知识整理工具，wiki是团队知识整理工具。
evernote 这个在线工具的中文名字叫印象笔记，类似的产品还有有道云笔记。
就像在上篇所说的，可以把它当做一个在线版本的working-dir，所有的碎片信息及时的整理到这里，并定期的归档。由于它是在线的，你基本不用担心数据丢失的问题，工作电脑随便换，硬盘随便换，只要你有可以记住自己密码的能力就可以！
我知道很多朋友是有一个小本本的，上面记了更种零碎信息，比如：x总需要的资源数量，小明的电话，某个网站的地址，客户s的地址等等，为什么不用电子版的呢？还环保…
当你需要的时候，直接搜索关键字，所有的信息一目了然，你的小本本显然不能这么高级…
wiki 企业wiki并没有太优秀的独立产品，大多数都集成在一个大产品中，例如Teambition、Worktile，当有些信息需要共享到团队中去时，wiki是一种非常优秀的手段，它可以作为知识整理和传递的工具。
作为知识整理工具，每条对团队都有用的信息可以清晰的记录在wiki里，团队内所有人可见，比如：”千万不要跟王老板提大保健”，”2015年度软件采购统计说明”等等，需要这些信息的同事会自己去查找，同时也会将一些有用的信息分享出来。注意wiki是(当前时间点的)最终知识，需要不断的整理和归纳，而中间过程的信息往往会组织在类似Teambition任务板的工具中。
项目中间知识(在Teambition任务板中)经过提取和精化产生团队知识(在类似wiki的工具中)
数据整理 再不济，企业也应该建立一个公共文件夹来存放共享数据吧？如果你的企业连这个都没有，每个同事都是：”姐，给我拷一下上一年的财务表”，这简直low一地。
有个最好用的工具叫DropBox，显然在我大中华用不了的，那么我们来尝试一些其它的工具。以下两个工具都提供全全台的同步功能，也就是说，当一个文件发生了变化，会自动同步到云端，然后其它客户端也会自动同步最新的文件，这对于企业是有意义的，谁也不想拿着合同去见客户，最后发现是v0.9的版本而并非最新的v1.0。
OneDrive 大微软提供，付费扩容量，速度杠杠的，自动同步文件，妈妈再也不用担心我司的数据。
百度网盘 免费版本可获3T空间，中小企业基本够用，再充个会员，速度也杠杠的，还提供文件版本历史记录，工作电脑随便换，硬盘随便换，妈妈也不用担心我司的数据。
如果企业对数据安全性相当的看重，那么还是自己架设文件服务器吧，这个我们以后再说。
最后，还是那句话，再牛逼的工具也解决不了人懒的问题，工具可以提高人类的工作效率，但是也得你去用才行，成天说自己快忙死了哪儿还有时间用这些花哨的东西的人，你就该一辈子在原地转圈，谁叫你不去动脑筋非要动蛮力呢对吧？
再最后，改变别人我们也许做不到，但是改变自己是可以做到的，正确的打开方式是：我提高了效率我轻松，而不是你降低了效率显得我轻松。</description></item><item><title>提高工作效率与幸福度-基本篇</title><link>https://lurongkai.github.io/posts/2015/04/28/improve-work-efficiency-and-happiness-1/</link><pubDate>Tue, 28 Apr 2015 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2015/04/28/improve-work-efficiency-and-happiness-1/</guid><description>现代企业有着复杂的协作，人与人间的信息交流、资源间的协调分配，各种碎片信息的整理，这还不包含人际关系处理等等狗血剧情，每天的工作被打散成七零八落，看似忙成狗，其实就是狗一般的活着，仰望天空，噢 shit 一天又特么过去了，好多事儿还没做完……
有没有办法通过改善自身来提高生产力？不妨看看这些行之有效的建议能否帮到你。要知道，这些建议来自于脑力协作最为密集的软件开发行业，对其实生产制造或者创造性工作也有着不错的借鉴意义。毕竟，自身的生产力提高了，才能从容的面对复杂的工作，从而让自己的竞争力更上一层台阶。
本文共分两部分：
《提高工作效率与幸福度-基本篇》，讲述老百姓自己的故事 《提高工作效率与幸福度-工具篇》，讲述新人类的工作方式 关于邮件 邮件是讨厌的。这和小雨伞有着相似之处，不想用但却不得不用。究其深层原因，是因为从邮件中提取有效信息是需要脑力成本的，你不能指望所有的合作者都有着清晰明了的思路。当然有改善这种情况的方式，但从历史角度来看，邮件还会继续存在下去，所以你需要做的，就是如何利用有限的资源来将邮件的生产能力提高。
首先，邮件应该尽量保持一致的阅读体验，从签名到字体，从颜色到排版。如何可能的话，在公司内部使用统一的邮件格式，这样能让信息的提取容易很多。例如，使用纯黑色或蓝黑色字体，中文字体设置成微软雅黑（已假定所有人使用 Win7+以上操作系统），英文字体使用 Calibri，字号统一设置成 14 号字体，大家阅读起来一目了然没有脑力负担。
其次，使用明确的人类可辨识的语言来说明，如果一件事情的关联性很多，不妨使用列表，用明确的短语来描述，人人为我我为人人，例如：
这件事情需要 A 来提交票据 审核任务需要在 25 号前完成 与第三方供应商的沟通还没有结果 这种做法可以行之有效的使信息表述的更为精准，尤其是当你收到一封说的不知所云的邮件时，用列表的方式向对方提问，一般来回不超过两封邮件就能使事情明确。
再次，邮件中或许提到了可能需要你参与的时间点，所以你需要借助日程工具来提醒自己在未来的时间点再介入。此时不妨点击 Outlook 上的 Meeting 按钮，为自己创建一个 Appointment，之后可以转做别的事情而不用时该记着还有事情没有做完。
最后，避免在一封邮件里讨论过多的信息。一封邮件只讨论一件事，除非这是封总结性的信息，无需要他们再介入讨论。当然，你需要一个明确的标题，比如“关于库存合并的时间”，必要时，你可以加入简单的标点符号来辅助说明，例如“[确认]一季度销售计划安排”，只有你不对他人造成困扰，才能让他们提供更加有用的信息。
另外，你需要养成定期整理邮件的习惯，一般建议是一天一整理。Outlook 中可以对邮件设置颜色标签，你可以按重要程度设置不同的颜色，如果手里有优先级更高的事情需要处理但是又不能忽略当前的邮件，那么完全可以设置邮件的 Follow Up 提醒，让机器代替人类记忆更加靠谱的。讨论结束后，可以对邮件进行归档，放置在不同的目录以供今后参考，不造成记忆负担，例如“Projects\2015\Da-Dou-Dou”。
关于电话 电话是强势介入，一般比邮件更具侵入性，如果不是特别要紧的事情，不要使用电话来直接 Call 别人，因为这样可能会打断他人正在进行的事情。放在软件开发者身上，接完电话可能需要 30-60 分钟才能恢复到原有的工作。
你需要想明白对方是否真的可以被你打断，比如对方正在上厕所……当然，这种打断在现代企业基本是不可避免的，所以这里提供两条建议以供参考：
如果正在进行一项优先级很高的任务不希望被中断，那么 OK 直接挂掉电话（看清谁来的电话），然后马上通过短信、邮件或其实方式回复一条简短的讯息：“我这会儿有重要的事情需要马上处理，30 分钟后马上与你联系，如果很紧急请再次联系我”。这样的反馈明确而有力度，确保你能保持高效。当然，如果对方再次 call 来，你就需要权衡利弊了，这不是演习。 如果你需要对方协助你处理一项事情，而且不是非常紧急，那么可以先通过其它非实时手段来询问一下时间，比如：“Jack, 我需要和你讨论一下 x 客户的合同问题，如果方便的话我会在 5 分钟内 call 你”，然后没响应的话 5 分钟 call 过去。当然，真的是要死要活的事情的话，也没必要有礼貌了，赶紧打电话吧。 相似的事情还有起身直接喊话，倒也不是什么大的问题，喊之前先说一句：“Tom，你有 3 分钟时间和我讨论一下 xxx 吗？”。如果别人是在问你而你很忙碌，你可以说：“稍等一下，我 10 分钟后再找你”（美剧中经常这么说：I&amp;rsquo;ll go back to you in ten mins.</description></item><item><title>使用异步编程</title><link>https://lurongkai.github.io/posts/2014/12/03/asynchronous-programming/</link><pubDate>Wed, 03 Dec 2014 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2014/12/03/asynchronous-programming/</guid><description>&lt;h2 id="导言">导言&lt;/h2>
&lt;p>现代的应用程序面临着诸多的挑战，如何构建具有可伸缩性和高性能的应用成为越来越多软件开发者思考的问题。随着应用规模的不断增大，业务复杂性的增长以及实时处理需求的增加，开发者不断尝试榨取硬件资源、优化。&lt;/p>
&lt;p>在不断的探索中，出现了很多简化场景的工具，比如提供可伸缩计算资源的 Amazon S3&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>、Windows Azure&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>，针对大数据的数据挖掘工具 MapReduce&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>，各种&lt;code>CDN&lt;/code>服务，&lt;code>云存储&lt;/code>服务等等。还有很多的工程实践例如敏捷&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>、DDD&lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup>等提供了指导。可以看到，将每个关注层面以服务的方式提供，成为了越来越流行的一种模式，或许我们可以激进的认为，这就是 SOA&lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup>。&lt;/p>
&lt;p>开发者需要将不同的资源粘合在一起来提供最终的应用，这就需要协调不同的资源。&lt;/p></description></item><item><title>coolshell puzzle guides</title><link>https://lurongkai.github.io/posts/2014/08/coolshell-puzzle-guides/</link><pubDate>Tue, 05 Aug 2014 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2014/08/coolshell-puzzle-guides/</guid><description>CoolShell博主陈皓做了一个在线的puzzle很有意思，链接在这里，这里记录一下解题的一些步骤。
Puzzle 0 ++++++++[&amp;gt;+&amp;gt;++&amp;gt;+++&amp;gt;++++&amp;gt;+++++&amp;gt;++++++&amp;gt;+++++++&amp;gt;++++++++&amp;gt;+++++++++&amp;gt;++++++++++&amp;gt;+++++++++++&amp;gt;++++++++++++&amp;gt;+++++++++++++&amp;gt;++++++++++++++&amp;gt;+++++++++++++++&amp;gt;++++++++++++++++&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;-]&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;-.+&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;---.+++&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;----.++++&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;+++.---&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;-.+&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;---.+++&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;---.+++&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;--.++&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;.&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;----.++++&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;---.+++&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;----.++++&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;. 如果之前没有听说过变态的编程语言，就让你见识一下。BrainFuck也称BF，是一门只有8个指令构成的图灵完备的语言。CoolShell博主陈皓写过一篇简单的介绍在这里 具体的指令解释不多说了，直接打长这里，把上面的指令粘进去，运行得到下一关的地址：welcome.html。
Puzzle welcome.html X * Y 2, 3, 6, 18, 108, ? What is the meaning of life, the universe and everything? 生命、宇宙以及任何事情的终极答案 这题有两个线索，首先是这串数字，其次是生命、宇宙以及任何事情的终极答案。数字序列找规律并不复杂，每个数字是前两个数字之积，那么直接用18 * 108的结果1944尝试进入下一关，发现只找到了一个答案。第二个答案很有意思，或者说很极客很宅，直接google发现和《银河系漫游指南》有关，wiki地址在这里。
用1944 * 42的答案81648进入下一关。
Puzzle 81648.html macb() ? lpcbyu(&amp;amp;gbcq/_\021%ocq\012\0_=w(gbcq)/_dak._=}_ugb_[0q60)s+ 放眼忘去是Dvorak键盘，点图片可以看到详细信息。那么意图很明显了，Dvorak和QWERTY键盘转换一下看看会怎么样？这里有个在线的转换工具，然后：
main() { printf(&amp;amp;unix[&amp;#34;\021%six\012\0&amp;#34;],(unix)[&amp;#34;have&amp;#34;]+&amp;#34;fun&amp;#34;-0x60);} WTF……搜了一下，这是87年国际C语言混乱大赛的一段代码。C语言了解不多，趁这个机会了解了解戳这里，还有这里，列一些解此题的关键知识点。
unix关键字相当于#define unix 1 数组的引用，array[num]和num[array]效果相同，所以(unix)[&amp;ldquo;have&amp;rdquo;] 等于&amp;quot;have&amp;quot;[unix]，结果是a，ASCII是0x61 0x61 + &amp;quot;fun&amp;quot; - 0x60相当于对fun右移0x61指针再左移0x60指针，也就是说fun右称一位，结果是un \021是换页，于是&amp;amp;unix[&amp;quot;\021%six\012\0&amp;quot;]约为&amp;amp;unix[&amp;quot;\n%six\n\0&amp;quot;]，%s被替为前面的un，&amp;amp;unix再跳过了第一个\n，所以结果是unix 使用unix，进入下一题。
Puzzle unix.html 微信扫码，得到：
[abcdefghijklmnopqrstuvwxyz] &amp;lt;=&amp;gt; [pvwdgazxubqfsnrhocitlkeymj] 看来是一个简单的替代，请出大shell
echo Wxgcg txgcg ui p ixgff, txgcg ui p epm.</description></item><item><title>运动改变思维</title><link>https://lurongkai.github.io/posts/2013/sport-change-mind/</link><pubDate>Thu, 11 Apr 2013 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2013/sport-change-mind/</guid><description>今年的春天开始，Ninja 逐渐的开始加强身体机能的锻炼，虽说没有惊天动地的成效，但是的确也带来了不错的效果。之前的日子波澜不惊，回过头来看发现过的挺颓的，尤其是 12 年从美国暴饮暴食回来后发现整个人胖的想死了，后知后觉后发现这种糟糕的状态真是可怕。是时候做出一些改变了。3 个月后，Ninja 从 80kg 降到了 72kg，并且还在朝着BMI推荐的体重 67kg 而努力。
饮食 和@阳总 之前有过一段时间的尝试，就是晚上只喝粥，原本是想吃清淡一些，配合一些减脂运动可能会有不错的效果，后来证明这一点真的是错的可怕。精食，尤其是米类和面食类并不能有效的起到减脂效果，淀粉转化后的葡萄糖会让你的脂肪感觉爽爽的，套用@阳总 的理工男思维：葡萄糖转化后的 ATP 可直接为人体提供能量，回想起来怕怕的。后续的故事是这样，连喝三天体重不掉，整个人看起来都是粥色了，出去大吃一顿，尝试别的方案。
之后 Ninja 开始认真的调整饮食习惯，不刻意的减少每顿的摄入量。少食多餐，中午的两荤一素也改为两素一荤，只要有饱腹感立即停箸，3 个月下来，感觉非常好，整个人都不油腻了。
从 13 年年底开始，Ninja 开始告别碳酸类饮料，偶尔喝也只喝果汁类的饮料，工作时间基本以白水为主，咖啡基本不喝。不能说碳酸类饮料不好，只是因为碳酸类的饮料会阻碍人体吸收一些微量元素，而这些微量元素恰好是对人体骨质所依赖的，所以不是碳酸根离子 + 钙离子 ＝&amp;gt; 碳酸钙从而导致骨质疏松，真正的原因是它阻碍了人类微量元素的吸收而产生的副作用（这一段是不是解释了 Ninja 为什么单身……）。
总之，调整一下饮食结构，避免过于油腻的食品，是增强身体机能的关键，至少起到不增肥的效果……
跑步 不得不承认，Ninja 过去体力一直很差，差到什么地步呢？上学那阵吵着和@马龟兽 去打球，10 分钟后说不行了（是体力不行了）回去打 Dota 吧。于是捏了捏已经九九归一的腹肌上的肥肉，抹去眼角的泪水开始坚持跑步做有氧运动减脂。刚开始的时候只能跑不到 5 分钟，然后小腿开始僵硬，第二天直接跪了休息了三四天，慢慢的发现跑的姿势以及节奏有问题。
跑步是不错的减脂方式，如果每天能坚持 30 分钟以上就可以达到减脂的目的。跑的时候臂摆幅度不宜过大，目视前方保持身体挺直，尤其在疲劳的时候更要保持身体不变形。在调整了正确的跑步姿势之后，体力的问题也开始慢慢的克服了，3 个月之后 Ninja 已经可以坚持以不慢的速度连续跑步 2km 以上（如果@阳总 不拖大腿根的话……），之后稍做调整还可以再跑 1km 回家洗澡看电影，整个过程呼吸均匀没有大的起伏。这个夏天结束后可以考虑跑 5km 路线往返了。
如果开始跑步，不需要天天坚持，因为身体仍然会有所损伤，即便是配备再牛逼的装备。跑 3 歇 1 是比较推荐的节奏。
Plank 平板支撑（Plank）可以有效的塑形，第一次 Ninja 坚持了大概 30 秒然后长趴不起……后来有了跑步对体能的加强，以及下面要说的 Badminton，整体上有了大幅的改善，虽然因为天气太热没有继续做 Plank，然而现在依旧保持了 2 分钟不跪的记录。当然，前提是标准的动作。
做 Plank 的那段日子，每每做完都感觉腹部灼热，像是做了很多的……俯卧撑，对俯卧撑，感觉整个腹肌就要爆出来了，赶紧美美的去照了照镜子找找人鱼线什么的，然后默默的洗个澡躺床上看书去了。不要怀疑，练 9 块这个最快了，而且 Ninja 觉得有腹肌的姑娘简直美到不能再美了。</description></item><item><title>MacOS密码恢复</title><link>https://lurongkai.github.io/posts/2013/02/22/how-to-recovery-macos-password-without-installation-cd/</link><pubDate>Fri, 22 Mar 2013 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2013/02/22/how-to-recovery-macos-password-without-installation-cd/</guid><description>方法一 官方解决方法。找出电脑原配的系统盘，找不到就借一张或者刻录一张，重启电脑，启动的时候按C键，选好语言后进入安装的时候，点击“常用工具”，里面有一项是“重设密码”，这时就可以重新设定Mac OS系统的管理员密码了。
方法二 黑客解决方法。开机， 启动时按cmd+S。这时进入单一用户模式（Single user model）。Mac OS的单一用户模式有准入特权（Root access privilege）而不要求根密码（root password）。出现像DOS一样的提示符 #root&amp;gt;。在#root&amp;gt;下逐步输入以下命令，注意空格，大小写
//执行硬盘检测（只读）, 这一步可以省略 /sbin/fsck -y //加载文件系统（读/写） /sbin/mount -uaw //删除初始化设置时的OSX生成的隐藏文件”.applesetupdone” rm /var/db/.AppleSetupDone //重启 reboot 重启开机后出现类似装机时的欢迎界面。别担心，东西没丢。就像第一次安装一样， 重新建立一个新的Mac OS管理员账号。然后在新的管理员下打开系统预制 － 账户，打开最下面的锁，询问密码时，用新的管理员密码登录。会看到至少两个账号，新的管理员的帐号和原来的帐号，点中原来的账号，选 密码 － 更改密码……（一切，从此改变） 你不必有原先的Mac OS密码就直接可以设新密码了。 点下面的登陆选项 (小房子)，选中 自动以右边的身份登陆， 同时在下拉菜单中选你原先的账号。 重启， 大功告成。至此破解Mac OS开机密码工作完成。 如果不喜欢多出一个账号， 删除它。 系统预制 － 账户，选新的管理员帐号， 点一下锁上面的减号。</description></item><item><title>初探Razor视图引擎</title><link>https://lurongkai.github.io/posts/2010/07/21/razor-quick-glance/</link><pubDate>Wed, 21 Jul 2010 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2010/07/21/razor-quick-glance/</guid><description>前一段时间，ScottGu在博客上发表了一些有关WebMatrix的文章，其中提到了一个新的ASP.NET视图引擎——Razor。
Razor有着非常简单和干净的语法，但是不管怎么样，它毕竟只是一个表现层面的东西，其底层仍然使用ASP.NET，与平时的开发没有什么大的区别，唯一的区别在于：视图的简洁。
安装 使用Razor需要安装 Microsoft ASP.NET Web Pages，当然，官方的做法是：直接用Web Plamform安装WebMatrix，不过WebMatrix现在还处于Beta阶段，估计以后会增加更多支持Razor的功能。
安装完毕后打开WebMatrix，然后就可以通过Site Form Template来新建一个站点测试了。
默认生成的站点在“我的文档”My Web Sites下以站点名命名。
初窥 Razor的语言简单之极，只需记住一个字符就可以：@。
在传统的ASP.NET视图引擎中，如果我们要进行一些数据绑定或者逻辑判断就会使用类似下面的做法：
&amp;lt;% var testStr1 = &amp;#34;Hello&amp;#34;; var testStr2 = &amp;#34;lurongkai&amp;#34;; %&amp;gt; 我们先搞了两个变量，当然，这些变量可以从任意的地方获得，然后，我们将这两个变量绑定到页面中去：
&amp;lt;%= testStr1 %&amp;gt;,Your name:&amp;lt;%= testStr2 %&amp;gt; 不知道您看的如何，总之我感觉是够乱的。
同样的东西，我们用Razor的语法来重写，会是怎么样的呢？
@{ var testStr1 = &amp;#34;Hello&amp;#34;; var testStr2 = &amp;#34;lurongkai&amp;#34;; } @testStr1,Your name:@testStr2 当然了，结果是一样的，不过在表现力上显然Razor更胜一筹，因为来回的&amp;lt;% %&amp;gt;看的人眼花，例如下面这个MVC中登陆部分的用户控件：
&amp;lt;% if (Request.IsAuthenticated) { %&amp;gt; 欢迎您，&amp;lt;b&amp;gt;&amp;lt;%: Page.User.Identity.Name %&amp;gt;&amp;lt;/b&amp;gt;! [ &amp;lt;%: Html.ActionLink(&amp;#34;注销&amp;#34;, &amp;#34;LogOff&amp;#34;, &amp;#34;Account&amp;#34;) %&amp;gt; ] &amp;lt;% } else { %&amp;gt; [ &amp;lt;%: Html.</description></item><item><title>.NET 4中的并行编程(下)</title><link>https://lurongkai.github.io/posts/2010/04/20/dotnet-parallel-programming-2/</link><pubDate>Tue, 20 Apr 2010 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2010/04/20/dotnet-parallel-programming-2/</guid><description>上一次主要讨论了在.NET 4中如何编写并行程序，这次继续上次的话题。
当我们有能力使用前面所介绍的一些结构来构建我们的应用程序时，一个需要考虑的场景是：假如一个并行过程已经开始，在它没有完成前想取消它的话应该怎么做呢？其实这个问题很现实，在多线程程序中也会遇到，当然了，多线程编程时我们可以用Thread.Abort()来终结它，那么在并行中该如何实现呢？老规矩，上Demo：
CancellationTokenSource tokenSource = new CancellationTokenSource(); CancellationToken token = tokenSource.Token; Task task1 = Task.Factory.StartNew(() =&amp;gt; { int i = 0; while (!token.IsCancellationRequested) { Thread.Sleep(500); Console.WriteLine(&amp;#34;Task1,{0}&amp;#34;, i++); } }, token); token.Register(() =&amp;gt; { Console.WriteLine(&amp;#34;Task1 has been canceled&amp;#34;); }); Console.ReadLine(); tokenSource.Cancel(); 首先实例化一个CancellationTokenSource对象，这个对象用于管理并行过程中的取消动作。当创建一个Task的时候，传入一个CancellationToken对象，而这个对象可以由CancellationTokenSource.Token属性来获得。当Task开开始执行时，如果想取消这个Task，那么就可以调用CancellationTokenSource.Cancel()来取消与之相关的Task了。
其实，我们可以将CancellationTokenSource理解为一个犯罪团伙的头目，然后这个头目管理着CancellationToken小兵，然后当一个Task创建时将这个小兵安插在其中(无间道？)，当头目发指令Cancel()时，小兵在Task内部上演无间道，嗯……
然而，出来混，迟早要还的。Task能不能无异常的执行完毕还是个未知数。在.NET 4中，现在可以用AggregateException来处理这些异常了，它提供一种异常汇总机制，可以对未知的异常进行处理，上一个Demo：
Task task1 = Task.Factory.StartNew(() =&amp;gt; { Console.WriteLine(&amp;#34;Task1 completed.&amp;#34;); }); Task task2 = Task.Factory.StartNew(() =&amp;gt; { Console.WriteLine(&amp;#34;Task2 processing.</description></item><item><title>.NET 4中的并行编程(上)</title><link>https://lurongkai.github.io/posts/2010/04/19/dotnet-parallel-programming-1/</link><pubDate>Mon, 19 Apr 2010 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2010/04/19/dotnet-parallel-programming-1/</guid><description>并行是.NET 4中新加入的特性，为了使程序在多核心多CPU环境运行的更好、更快、更强大。
并发和并行是不一样的，并发最多可以算做是多线程，而所谓并行是将任务分散到不同的CPU上同时执行。尤其值得我们关注的是，在Web环境下的先天并行特性，使得并行编程成为解决性能瓶颈的又一武器。
.NET 4中的并行编程主要是Parallel和Task，微软强势构建了TPL(Task Parallel Library)，使开发过程变得简洁。
接下来，先看一个简单的Demo：
using System.Threading.Tasks; Parallel.Invoke( () =&amp;gt; { Thread.Sleep(1000); Console.WriteLine(&amp;#34;1&amp;#34;); }, () =&amp;gt; { Thread.Sleep(1000); Console.WriteLine(&amp;#34;2&amp;#34;); }, () =&amp;gt; { Thread.Sleep(1000); Console.WriteLine(&amp;#34;3&amp;#34;); }); Parallel.Invoke()方法可以接收一个Action委托的params数组。我们来猜一下上段代码的执行结果是什么？123的顺序还是132？213？231？这个，不一定，得看人品……呵呵，开个玩笑，并行执行时，将上面三个Lambda表达式传递的方法分别看做一个“任务”，将其分配至空闲CPU，然后执行，由于CPU的情况是不一定的，所以执行完毕的顺序也就有了差异。
由于很多需要并行执行的任务都有一定的相似性，所以一般情况下我们可以用一种类似for循环的方式对这些任务进行并行的处理，例如在.NET 4中可以这么做：
Parallel.For(0, 10, i =&amp;gt; { Console.WriteLine(i); }); 但样做有时却不方便，例如我们要处理一个集合中的数据，既然集合实现了IEnumerable接口，为什么还要用索引来遍历呢？
其实我们是可以方便并行的处理一个数据集合的，以在多CPU环境下获得更高的性能。具体的，我们可以这么做：
var dataList = new string[] { &amp;#34;data1&amp;#34;, &amp;#34;data2&amp;#34;, &amp;#34;data3&amp;#34; };//IEnumerable interface. Parallel.ForEach(dataList, taskOptions, data =&amp;gt; { Console.</description></item><item><title>.NET 4在CLR和BCL的一些变化(3)</title><link>https://lurongkai.github.io/posts/2010/04/13/dotnet-4-changes-on-clr-and-bcl-3/</link><pubDate>Tue, 13 Apr 2010 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2010/04/13/dotnet-4-changes-on-clr-and-bcl-3/</guid><description>VS2010正式版发布了，从海报中我们可以看到.NET 4在BCL上的改进还是很大的，这一次主要讨论比较Core的变化。
就照海报的顺序说吧。
System.Collections.Generic .NET 4中新加入了名为SortedSet&amp;lt;T&amp;gt;的结构，这是一个很有用的结构，它在内部维护一个集合，使用Add()向SortedSet中添加已存在的项时会被忽略，并且返回false。
SortedSet sortedSetDemo = new SortedSet { 8, 2, 1, 5, 10, 5, 10, 8 }; SortedSet和HashSet均实现了新引入的ISet接口，其实可以看下ISet的签名：
public interface ISet&amp;lt;T&amp;gt; : ICollection&amp;lt;T&amp;gt;, IEnumerable&amp;lt;T&amp;gt;, IEnumerable 于是可以知道SortedSet是一个集合，同时可遍历，可……
System.IO.MemoryMappedFiles 这个结构的作用在于将一个文映射到内存中，以达到快速“IO”的目的。其实MemoryMappedFiles的真正作用是用作进程间或应用程序间的通信，在内存映射文件中存储相关的信息然后传递。下面这个例子简单演示了如何使用MemoryMappedFiles：
using System.IO; using System.IO.MemoryMappedFiles; using (MemoryMappedFile MemoryMappedFile = MemoryMappedFile.CreateNew(&amp;#34;MemoryMappedFileDemo&amp;#34;, 100)){ MemoryMappedViewStream stream = MemoryMappedFile.CreateViewStream(); using (BinaryWriter writer = new BinaryWriter(stream)){ writer.Write(&amp;#34;hello cnblogs&amp;#34;); } } 这样我们就将一个名为MemoryMappedFileDemo的“文件”写入到了内存，下面的代码说明怎样将它读出来，要注意的是，两段代码不要写在一个应用程序内，否则会报错。
using (MemoryMappedFile MemoryMappedFile = MemoryMappedFile.OpenExisting(&amp;#34;MemoryMappedFileDemo&amp;#34;)) { using (MemoryMappedViewStream Stream = MemoryMappedFile.</description></item><item><title>.NET 4在CLR和BCL的一些变化(2)</title><link>https://lurongkai.github.io/posts/2010/04/12/dotnet-4-changes-on-clr-and-bcl-2/</link><pubDate>Mon, 12 Apr 2010 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2010/04/12/dotnet-4-changes-on-clr-and-bcl-2/</guid><description>上一篇讨论了.NET 4中关于垃圾回收、线程、并行、全球化等方面的内容，这次我们接着上次往下说。
安全 安全是一个很大的概念。在.NET 4中，主要的改进在于对CAS操作的简化。
先前的版本中，如果想要控制资源的安全访问，那么就会使用CAS策略，但是操作往往很复杂，4改进了操作，主要体现在这些方面：
改进的透明模型。透明模型将代码分为了安全、不安全、或许安全，当然，这取决于程序宿主机的设置。于是.NET为不同应用程序设置了不同的安全类型，就像我们平常知道的那样，ASP.NET和SQL, Silverlight可以运行代码的安全级别都不一样，这都是CAS策略所管理的。先前的透明模型主要和一些代码检查工具如FxCop等协同来审核代码。
透明模型有三种类型：透明代码、关键代码、安全关键代码，分别代表的代码的不同安全等级。当.NET 4的应用程序以部分信任运行时，CLR将确保透明代码可以调用其它的透明和安全的代码。并且，在程序调用安全的同时，CLR要求一定的权限才能执行，这个权限是通过程检查程序宿主机的设置来确认的。
与过去不同的是，.NET 4将通过Windows Explorer和网络共享运行的代码定义为完全信任，换句话讲，它们的等级是相同的，而先前的版本中，两者的运行等级并不相同。而运行在主机的应用程序，不管是ASP.NET或是Silverlight，将使用主机授权，也就是说我们只需要考虑授权这些应用程序以不同的权限。部分信任的应用程序已经对其有了必要的限制，对于非本机的代码，微软建议我们使用SRPs(Software Restriction Policies软件限制策略)来应用安全策略，这个东东可以在托管代码和非托管代码上应用，具体的大家查查MSDN。
新的版本中，已经删除了在CLR中有关Deny, RequestMinimum, RequestOptional, RequestRefuse的权限要求，所以说如果要迁移程序到新版本，一定要删除相关的代码才行，不然会报错。
缝缝补补，.NET 4终于可以不用像以前那样繁琐的来控制应用程序的权限相关的问题了。另外值得注意的是，.NET 4中有了一个PartialTrustVisibilityLevel的特性(Attribute)，使用这个特性，我们可以在部分信任的应用程序中，调用一些需要完全信任权限才能调用的程序集，这对于我们是一个好消息，尤其是ASP.NET应用程序。CAS的使用需要辅以“证据”，我们可以看看下图中CAS的构建模块：
.NET 4中的证据类型基类Evidence现在可以确保继承它的证据类型是非空和可序列化的。额外的，新加入了一些方法可以用于查询证据的具体类型，这在先前的版本中是通过遍历来实现的。
监测与分析 .NET 4的改进中不得不提的是，我们现在可以获取每个应用程序域关于CPU和内存的使用情况了，这对于ASP.NET应用程序是个不错的功能，很多时候我们需要知道应用程序的状况来做相关的优化时却措手无策，现在好了，新的改进可以使开发人员从容淡定的了解其应用程序的运行状况，然后淡定的修修补补，OK，效率上去了。
当然了，新的API肯定是有的，新增的API可以用做profiling和debugging，总的原则就是改善程序员的生存状态，不要累死在Debug上，嗯。
监测程序不正常的传统做法就是异常处理，我们经常这么做：
try { //Do some thing } catch(System.exception e) { //... } 这种做法很不推荐，因为所有的异常将被隐藏，然而我们往往希望一些异常不要被捕获，例如一些可以访问冲突或者调用非法指令的异常，这时应该让程序在出现异常时退出来而不是由catch将所有的异常捕获，因为这些异常具有一定潜在的危险性。.NET 4中引入了新的特性，那就是在方法体上标注[HandleProcessCorruptedStateExceptions]，这样，当破坏状态的异常出现时，将不会被catch捕获了。
那如果想捕获这些破坏状态的异常，比如将它传递到一个异常Logging类，好办，应用程序配置文件里加入这么一行：LegacyCorruptedStateExceptionsPolicy = true，catch就可以捕获到它了。
Dynamic的引入与DLR 这个特性绝对是.NET 4的重头戏，将它与Parallel特性封为4上最重要的功能一点也不过分。
先让我们来看一下先前版本的.NET对加入动态语言到.NET框架时是怎么做的：
可以看的出，Python和Ruby等这些动态语言是通过直接原生的在CLR上编写而实现移植。我们有理由想像在一个非动态的运行时上实现动态语言的难度是何等之大！
.NET 4提出的DLR是一个动态语言运行时，也就是说是微软官方提供的在CLR的基础上提供一层动态语言抽象层，来实现“门门语言为我，我为门门语言”的大友好框架主义，在此特性上，要移植一门动态语言到.NET平台上，好，去找DLR，那静态语言呢？直接去搞CLR。举个例子，今天我看上Javascript这姑娘了，想搞出个Javascript.NET，以实现我浏览器大友好.NET主义，理论上可行，可以联系DLR大哥；隔天又看上Java了……算了，我们换个例子，看上Scale了，好，给你张CLR的名片，我等.NET民众合谐友好。
那么具体的DLR在.NET 4所处的处置就是下面这个样子：
咦？C#和VB也可以使用DLR？当然了，为了交互的方便么。所以我们可以介绍怎样在C#等静态语言中使用动态语言的功能了。
于是我们有理由相信，.NET 4上的语言会越来越多，事实从一些消息上看，好像已经有二三十种的样子，著名的好像还是一些比较大的语言。当Python和Ruby在DLR上开始构建时，我相信可以实现的灵活度会大大提高。下面是官方的一张PPT：
当然了，这是编程层面的东西，例如C#和VB.NET其实是构建在CLR上的，只不过可以通过DLR来实现一些动态编程的特性。
.NET 4新加入的动态功能可以使我们方便的在运行时获取一个未知类型的对象并对其进行操作。同样的，构建在DLR基础上的动态语言也可以通过DLR -&amp;gt; CLR的方式来使用.NET类库。所以我们有理由相信，在使用COM方面，也将更加的简化。
动态语言是指在编译期不进行类型检查，在运行时动态的确定类型，这样的做的好处在于我们不必对未知的类型进行抽象，完全将其放在运行时动态的解析。然而其缺点也显而易见，那就是无法使用智能感知等强类型语言才拥有的特性，因此Debug也相对较困难一些。值得注意的是，动态语言的运行效率一定不会很高，因为在运行时进行解析是非常耗费资源的，并且对DLR来说，多一层抽象所带来的性能损失绝不对小视。我们可以想像一下将C#移植到Java平台上或者相反，理论上完全可行，因为.NET平台Java平台具有一定的相似性，对Java Bytecode和MSIL之间转换即可，然而效率问题确值得商榷。多一层抽象就多一层损耗，所以，在静态语言中使用动态特性一定要谨慎，不要滥用。
但是如果好奇，那么我们可以写个用反射来使用动态特性的Demo：
object UsingReflection = Activator.CreateInstance(Type.GetType(&amp;#34;System.Text.StringBuilder&amp;#34;)); Type ObjectType = UsingReflection.</description></item><item><title>.NET 4在CLR和BCL的一些变化(1)</title><link>https://lurongkai.github.io/posts/2010/04/11/dotnet-4-changes-on-clr-and-bcl-1/</link><pubDate>Sun, 11 Apr 2010 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2010/04/11/dotnet-4-changes-on-clr-and-bcl-1/</guid><description>VS2010明天就要发布了，伴随而来的是.NET Framework第四个版本的发布，借这个机会，聊聊相对于3.5，4又多了哪些新的特性。
我们知道，.NET Framework是一个渐近发展的框架，自从2.0开始，框架底层本身并没有太大的变化，CLR的版本都是2.0的，4的发布是一个质飞跃，微软直接跳过了CLR 3.0的版本而将.NET Framework的版本更新为4，如此看来，先前3.0，3.5的程序可以在2.0的运行时上运行，想在新的运行时上运行的话必须要重新编译了。
.Net Framework 3.0加入了一些诸如WPF,WCF,WF,WCS的东西，3.5又更新了一些EF，LINQ的新特性，那么我们有理由相信4也将会带给我们更多的惊喜，这个惊喜便是：Parallel和DLR。
GC CLR 2.0的运行机制大家一定很熟悉了，CLR为应用程序分配内存并且在适当的时候执行垃圾回收来释放内存。这里所说的适当可以理解为系统内存数量低或者其他对内存需求超过程合理范围的时候。
GC是怎么判断一个对象该执行清理了呢？CLR在内部建立了对象图来确定一个对象是否引用数为0，为0也就是不可达，清理之。CLR将分配内存的对象标记为0代，1代，2代，新分配的对象默认为0代，当CLR执行一次GC操作后没有被清理的对象将上升为1代，再清理，再升为2代，再清理，还是2代……不用多想，在CLR 2.0中最高就是2代。
GC的工作模式有3种：workstation, concurrent workstation, server，其中workstation是默认模式，而server模式用于多CPU服务器环境。workstation自不必细说，但是concurrent workstation模式下当一个GC正在执行中时，其他的GC是无法同时执行的。换句话讲，在concurrent workstation下GC的执行效率并不高，而server模式会开启一个新线程来进行GC操作，然而单个CPU上执行GC却和concurrent workstation相同。
那么CLR 4会有什么新的特性呢？一切为了效率，一切为了并行！CLR 4提出了后台GC来替代concurrent workstation模式。后台GC支持与其他的GC同时执行。换句话讲，减少了GC执行的时间，资源可以更早的被释放。
但是后台GC这种特性在server模式上却不可用，不知道在后续版本中会不会改进。
先前版本的GC运行机制详情请猛击PriorGC。
Cool，与Parallel不谋而合，并行真是大势所趋……
线程 线程上的改进主要在线程池上。
先前的线程池在获取线程信息上是很困难的，这不利于我们优化程序，于是.NET 4新提出了一个新的更加友好的数据结构：Task，较先前的ThreadPool而言效率更高，对GC也更加的友好。
一个简单的示例：
在.NET 4以前的版本里，我们可以这样使用线程池：
ThreadPool.QueueUserWorkItem(_ =&amp;gt; { Console.WriteLine(&amp;#34;Hello world!&amp;#34;); }); 而在.NET 4中我们多了些选择：
Task newTask = Task.Factory.StartNew(() =&amp;gt; Console.WriteLine(&amp;#34;Hello world!&amp;#34;)); 但是要注意到的是，现在我们可以通过程newTask.Status来获取一个TaskStatus枚举，这个枚举说明了当前Task的执行状态，当然了，还有很多的属性，总之，可以获取很多的运行时状态，而这一切在ThreadPool是做不到的。
并行 说到线程上的改进就不能不提.NET 4的并行特性。新加入的支持并行特性的有
TPL(Task Parallel Library并行任务库)和CCR(Concurrency and Coordination Runtime并发与协调运行时) PLINQ(并行LINQ) 并发数据结构 PPL(Parallel Pattern Library并行模式库) 当然了，还有一些支持并行开发的必要工具。大家知道并发和并行是两个不同的概念，主要体现在对CPU的使用方式上不同。并发多指的是多线程，而并行是多CPU同步执行，一个图示如下：
但是值得注意的是，并线与多线程会加重程序的复杂度。并行程序可以显著提高程序在多CPU环境下的执行效率，然而同步与死锁的问题仍然没有完美的解决，并且难于调试(虽然VS2010的IDE提供了很大的支持)，与多线程相同，在开发时要注意这一点。</description></item><item><title>mht和chm文件打不开的解决方法</title><link>https://lurongkai.github.io/posts/2010/01/20/issues-of-mht-and-chm/</link><pubDate>Wed, 20 Jan 2010 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2010/01/20/issues-of-mht-and-chm/</guid><description>先引入这两种文件：
mht IE保存的文件格式，也不知道是什么版本开始成为默认的网页保存格式。 chm 不用解释了吧。 情况是这样：双击mht文件打不开，双击chm文件打开后无法显示。
怎么办呢？
仔细检查了一下，发现了一些问题：文件名中是包含了一些特殊的字符，例如文件名为C#测试.mht，这样的话就会出现上述的问题。
为了进一步研究，尝试用正常的文件名，但是将路径中的目录名改为包含特殊的字符，也出现了上述的问题。
看来在文件名和路径中不能出现特殊的字符，那么在IE中将这些特殊的字符进行转义（或者称之为Encode更为合适）行不行呢？答案是：不行。
接下来有理由怀疑所谓的“特殊字符”绝不止#这一个字符，如果大家遇到类似的问题可以尝试检查文件名或者路径，估计这样可以解决99%的所谓mht文件打不开的故障吧。
（上述问题已经反馈到微软，暂时没有一个完整解决方案，例如补丁什么的）
说完.mht，回过头来说.chm。
我的解决方案就一条：参照上述解决方法，原因是我已经用这种方法解决了，如果不行，请Google之。</description></item></channel></rss>