<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Collaboration on 程序物语</title><link>https://lurongkai.github.io/tags/collaboration/</link><description>Recent content in Collaboration on 程序物语</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 02 Mar 2017 00:00:00 +0800</lastBuildDate><atom:link href="https://lurongkai.github.io/tags/collaboration/index.xml" rel="self" type="application/rss+xml"/><item><title>理性沟通的团队</title><link>https://lurongkai.github.io/posts/2017/03/02/retional-team-with-communication/</link><pubDate>Thu, 02 Mar 2017 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2017/03/02/retional-team-with-communication/</guid><description>部分整理自Shinetech 2016-10-19内部分享）
《敏捷软件开发宣言》 我们一直在实践中探寻更好的软件开发方法，身体力行的同时也帮助他人。由此我们建立了如下价值观：
个体和互动 高于 流程和工具 工作的软件 高于 详尽的文档 客户合作 高于 合同谈判 响应变化 高于 遵循计划
也就是说，尽管右项有其价值，我们更重视左项的价值。
小而精的团队，往往更具有战斗力。我们提倡敏捷，也愿意相信它的价值，然而敏捷的实践却不仅仅是清晨站会、打打估算扑克那么简单。在我看来，其中最容易被忽视的一句便是：尽管右项有其价值，我们更重视左项的价值。如果一个开发者不写文档的理由是“我敏捷”，这就大错特错了，我所理解的敏捷，是关于『沟通』和『协作』的方式。
沟通自然重要，信息在传递中存在损失的可能，所以提倡尽可能的与客户直接沟通获取一手信息，避免经手N个人才到最终的实施者。同样的，部分信息也需要共享给团队成员或者stakeholder，由于沟通存在成本，所以方式方法亦很重要。
团队也需要协作，看板驱动带来潜在的负面影响就是每个人只关注用例，对项目整体的看法缺失，成员间的协作变少，由此在整个项目上出现了不同的视角。短期内任务是完成了，长远看分裂会逐渐积累。
敏捷是关于一个团队整体的态度，那么什么样的态度对团队是有益的呢？我们不妨审视一下以Github为代表的开源开发方式，并引入多种可用的工具，看能不能从中受到一些启发。
信息的推送与管理 程序员不喜欢邮件，认为邮件是浪费生命。无缘无故的被加入到邮件列表中，看着大家开始扯皮，扯到最后发现和自己没有一分钱关系，尴尬的是不看又不确定和自己有没有关系。又或者突然转发给自己了一封邮件，打开里面长长的对话，读了很久才知道说了什么。
这里的问题在于，邮件并不适合归档和提取信息，并且是强干扰因素。不妨回想一下，有没有参与这样一种项目，就是全程没有文档，进入项目组的当天转给你N封邮件让你读？再或者，连看板工具也没有，大家通过一个excel文件，标成黄色背景的你做，标成绿色背景的我做，彼此通过邮件来发送这个excel文件？
换一种思路，如果没有邮件，我们如何沟通？
Github有个非常好用的工具：Issues，任何人有问题、建议、计划等都会在里面建条目，然后完善Issue的详情并且展开讨论。上千人协作的项目用它用的不亦乐乎，这里的关键在于，信息完全是公开的，任何人都可以讨论，每个人只在必要的时候介入。同时，信息的噪音也很小。
这也是为什么Github被称为社交化编程。形象的打个比方，邮件好比写博客打架，你写一篇我写一篇，观点被不断放大，而Issue为基础的工作流则更像是Twitter，我说『filtering()方法出错了，报null异常』，下面有人回复『L30的null检查没有做，@Javis 请看一下』。
接下来，对PM来说，看来这个优先级比较高，马上打了个critical的标签，然后放在了current-milestone并分配给了@Javis，即刻，@Javis的上桌面上收到了通知，1分钟改好后提交了。
由于故事本身被限制在了一个很小的Item中，每个人可以更加关注于其本身。如果需要引入类似看板的功能，推荐大家试用ZenHub扩展。
另外，诸如Teambition, Tower, Trello这样的工具也可以提供灵活的任务管理，将一个大的用例切成小的部分，针对每个部分单独讨论，可以降低沟通成本，并且为归档提供了更多参考，不过，这些工具更倾向于客户与开发团队间针对需求和进度的沟通。
如果只是开发团队内的沟通，Github Issues, Jira, Redmine这些耳熟能详的缺陷跟踪工具一定可以帮助团队，让信息更加的透明，尽可能的减少信息干扰，降低沟通的成本。
随时共享你的想法 任务管理，或者缺陷跟踪的本质，是为了让信息便于管理和推送，同时带来一个新的挑战就是信息的归档。有很多的任务，其下对应的讨论是很有价值的，如果整个Item都是有限定的在讨论，那么从中提取信息就会变得容易。更进一步，可以将用例的讨论变成使用手册吗？可以将针对某个具体技术点的讨论变成团队共享的知识库吗？
知识库是全团队受益的，虽然敏捷认为文档的优先级不是最高的，但是绝不是说它不重要。对于程序员来说，有时候并不是不愿意写文档，而是写文档的工具不好用。
从Github得到的安利，就是好用的wikis工具，你值得拥有。结构化的文档体系，不需要安装任何软件就能写，每个人都能编辑完善，告别word和excel。
PM和开发人员应该对产生的Issues（或者叫Task）保持敏感，随时准备好提取和分享这些知识。而Email驱动的工作流养成的坏习惯，就是当需要将一些信息提供给他人时，不做任何修饰的把邮件列表转发出去。
当引入Issues（Task）驱动的工作流时，在它结束或close的时候，是最好的审视时机，回顾一遍，看有没有什么能共享的可以尝试归纳整理，分享是会上瘾的。
这件事，还有个非常著名的名词，叫做『知识传递』。
怕花钱？怕信息泄露？不妨试试Gollum（Github的wikis也是用它），其它的任务管理、缺陷管理工具也大部分也都提供wikis工具（例如Redmine, Jira），一朝架设终身受益啊。
非正式的沟通 有时候面对面的沟通，或者电话会议是无法避免的。任务管理工具也有自身的短板，就是不适合讨论非常复杂的问题。
Skype在语音方面的表现相当的好而且免费，但是作为一个消息工具，它的确显得不怎么好用，或许在与客户沟通时使用Skype已经足够了，但是对程序员来说，频繁的分享代码片断，或者在群聊中@某个人时，它的表现并不抢眼，想加粗某段话都不支持。
QQ，微信，更不用说，只聊天还行，协作并不是他们所擅长的。
程序员需要更好的交流工具，尤其是文字的。如果已经使用了Github Issues，就会发现，@某个人，或者链接某段代码非常方便，再者，贴出的代码带有语法高亮让人看着非常舒服，毕竟，程序员之间经常说“黑话”，一段没有高亮并且不是等宽字体的代码非常跌份儿。诚然，Issues作为非正式的沟通工具还是显得太不正式了……
不如，试试火爆全球的Slack？基于轻量级的Channel（可以想像成一个随意进出的微信群）可以快速拉几个人进行讨论某个Subject，丰富的ref功能可以随意的@人和链接一切，尤为重要的，就是它支持Markdown，而且它足够的轻量，相信试用一下就会爱上它的。
这并不是故事的全部，最有杀伤力的一点，它可以集成进任何的系统，持续集成、持续部署、运维监测、自动化机器人，比如@WallE deploy production，就会触发部署消息传递到你的运维系统开始部署，试试吧。
当然了，国外有的中国就早晚会有，就像twitter和微博……国内的『简聊』（Teambition团队做的）做的也非常不错，功能类似，推荐一试。
善用VCS工具 Github带来的另一个启迪，就是关于源代码管理的方式。众多的VCS工具，从TFS到svn，从Mercurial到git，无疑给了我们太多的选择，用好哪一个都会带来极大的生产力提高，然而事实并不如此。
很多的团队，仍认为VCS就是个存代码的地方，这或多或少的会给流程带来一定的影响。Github提供的思路很独特，在git的基础上创新的提供了pull request工作流。我们都确信code review带来的价值，我们也认同unit testing为QA带来的红利，但事实上做的人很少，有流程和其它的原因，当然也有工具不够好用的原因。
而pull request这种方式为我们提供了一种思路。善用工具，就得理解工具背后的文化，比如从svn迁移到git，就不应该在同一个分支上死签入到底了。从任务管理或缺陷管理工具开始一个新的任务，马上新开一个分支，不断的提交与实现，当完成时发起pull request让团队内的其它人来review是一种很好的知识传递的方式，同时，在pull request的窗口期内也可以不断的改善，确保最终的合并是一种完整的合并，这种一致化的体验在其它的VCS系统中是很难做到的。
相信工具的力量，架个git试试吧，别用svn了，比如试试Gitlab, Gogs，或者用在线的coding.</description></item></channel></rss>