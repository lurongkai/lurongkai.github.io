<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>.NET on 程序物语</title><link>https://lurongkai.github.io/tags/.net/</link><description>Recent content in .NET on 程序物语</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 20 Apr 2010 00:00:00 +0800</lastBuildDate><atom:link href="https://lurongkai.github.io/tags/.net/index.xml" rel="self" type="application/rss+xml"/><item><title>.NET 4中的并行编程(下)</title><link>https://lurongkai.github.io/posts/2010/04/20/dotnet-parallel-programming-2/</link><pubDate>Tue, 20 Apr 2010 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2010/04/20/dotnet-parallel-programming-2/</guid><description>上一次主要讨论了在.NET 4中如何编写并行程序，这次继续上次的话题。
当我们有能力使用前面所介绍的一些结构来构建我们的应用程序时，一个需要考虑的场景是：假如一个并行过程已经开始，在它没有完成前想取消它的话应该怎么做呢？其实这个问题很现实，在多线程程序中也会遇到，当然了，多线程编程时我们可以用Thread.Abort()来终结它，那么在并行中该如何实现呢？老规矩，上Demo：
CancellationTokenSource tokenSource = new CancellationTokenSource(); CancellationToken token = tokenSource.Token; Task task1 = Task.Factory.StartNew(() =&amp;gt; { int i = 0; while (!token.IsCancellationRequested) { Thread.Sleep(500); Console.WriteLine(&amp;#34;Task1,{0}&amp;#34;, i++); } }, token); token.Register(() =&amp;gt; { Console.WriteLine(&amp;#34;Task1 has been canceled&amp;#34;); }); Console.ReadLine(); tokenSource.Cancel(); 首先实例化一个CancellationTokenSource对象，这个对象用于管理并行过程中的取消动作。当创建一个Task的时候，传入一个CancellationToken对象，而这个对象可以由CancellationTokenSource.Token属性来获得。当Task开开始执行时，如果想取消这个Task，那么就可以调用CancellationTokenSource.Cancel()来取消与之相关的Task了。
其实，我们可以将CancellationTokenSource理解为一个犯罪团伙的头目，然后这个头目管理着CancellationToken小兵，然后当一个Task创建时将这个小兵安插在其中(无间道？)，当头目发指令Cancel()时，小兵在Task内部上演无间道，嗯……
然而，出来混，迟早要还的。Task能不能无异常的执行完毕还是个未知数。在.NET 4中，现在可以用AggregateException来处理这些异常了，它提供一种异常汇总机制，可以对未知的异常进行处理，上一个Demo：
Task task1 = Task.Factory.StartNew(() =&amp;gt; { Console.WriteLine(&amp;#34;Task1 completed.&amp;#34;); }); Task task2 = Task.Factory.StartNew(() =&amp;gt; { Console.WriteLine(&amp;#34;Task2 processing.</description></item><item><title>.NET 4中的并行编程(上)</title><link>https://lurongkai.github.io/posts/2010/04/19/dotnet-parallel-programming-1/</link><pubDate>Mon, 19 Apr 2010 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2010/04/19/dotnet-parallel-programming-1/</guid><description>并行是.NET 4中新加入的特性，为了使程序在多核心多CPU环境运行的更好、更快、更强大。
并发和并行是不一样的，并发最多可以算做是多线程，而所谓并行是将任务分散到不同的CPU上同时执行。尤其值得我们关注的是，在Web环境下的先天并行特性，使得并行编程成为解决性能瓶颈的又一武器。
.NET 4中的并行编程主要是Parallel和Task，微软强势构建了TPL(Task Parallel Library)，使开发过程变得简洁。
接下来，先看一个简单的Demo：
using System.Threading.Tasks; Parallel.Invoke( () =&amp;gt; { Thread.Sleep(1000); Console.WriteLine(&amp;#34;1&amp;#34;); }, () =&amp;gt; { Thread.Sleep(1000); Console.WriteLine(&amp;#34;2&amp;#34;); }, () =&amp;gt; { Thread.Sleep(1000); Console.WriteLine(&amp;#34;3&amp;#34;); }); Parallel.Invoke()方法可以接收一个Action委托的params数组。我们来猜一下上段代码的执行结果是什么？123的顺序还是132？213？231？这个，不一定，得看人品……呵呵，开个玩笑，并行执行时，将上面三个Lambda表达式传递的方法分别看做一个“任务”，将其分配至空闲CPU，然后执行，由于CPU的情况是不一定的，所以执行完毕的顺序也就有了差异。
由于很多需要并行执行的任务都有一定的相似性，所以一般情况下我们可以用一种类似for循环的方式对这些任务进行并行的处理，例如在.NET 4中可以这么做：
Parallel.For(0, 10, i =&amp;gt; { Console.WriteLine(i); }); 但样做有时却不方便，例如我们要处理一个集合中的数据，既然集合实现了IEnumerable接口，为什么还要用索引来遍历呢？
其实我们是可以方便并行的处理一个数据集合的，以在多CPU环境下获得更高的性能。具体的，我们可以这么做：
var dataList = new string[] { &amp;#34;data1&amp;#34;, &amp;#34;data2&amp;#34;, &amp;#34;data3&amp;#34; };//IEnumerable interface. Parallel.ForEach(dataList, taskOptions, data =&amp;gt; { Console.</description></item><item><title>.NET 4在CLR和BCL的一些变化(3)</title><link>https://lurongkai.github.io/posts/2010/04/13/dotnet-4-changes-on-clr-and-bcl-3/</link><pubDate>Tue, 13 Apr 2010 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2010/04/13/dotnet-4-changes-on-clr-and-bcl-3/</guid><description>VS2010正式版发布了，从海报中我们可以看到.NET 4在BCL上的改进还是很大的，这一次主要讨论比较Core的变化。
就照海报的顺序说吧。
System.Collections.Generic .NET 4中新加入了名为SortedSet&amp;lt;T&amp;gt;的结构，这是一个很有用的结构，它在内部维护一个集合，使用Add()向SortedSet中添加已存在的项时会被忽略，并且返回false。
SortedSet sortedSetDemo = new SortedSet { 8, 2, 1, 5, 10, 5, 10, 8 }; SortedSet和HashSet均实现了新引入的ISet接口，其实可以看下ISet的签名：
public interface ISet&amp;lt;T&amp;gt; : ICollection&amp;lt;T&amp;gt;, IEnumerable&amp;lt;T&amp;gt;, IEnumerable 于是可以知道SortedSet是一个集合，同时可遍历，可……
System.IO.MemoryMappedFiles 这个结构的作用在于将一个文映射到内存中，以达到快速“IO”的目的。其实MemoryMappedFiles的真正作用是用作进程间或应用程序间的通信，在内存映射文件中存储相关的信息然后传递。下面这个例子简单演示了如何使用MemoryMappedFiles：
using System.IO; using System.IO.MemoryMappedFiles; using (MemoryMappedFile MemoryMappedFile = MemoryMappedFile.CreateNew(&amp;#34;MemoryMappedFileDemo&amp;#34;, 100)){ MemoryMappedViewStream stream = MemoryMappedFile.CreateViewStream(); using (BinaryWriter writer = new BinaryWriter(stream)){ writer.Write(&amp;#34;hello cnblogs&amp;#34;); } } 这样我们就将一个名为MemoryMappedFileDemo的“文件”写入到了内存，下面的代码说明怎样将它读出来，要注意的是，两段代码不要写在一个应用程序内，否则会报错。
using (MemoryMappedFile MemoryMappedFile = MemoryMappedFile.OpenExisting(&amp;#34;MemoryMappedFileDemo&amp;#34;)) { using (MemoryMappedViewStream Stream = MemoryMappedFile.</description></item><item><title>.NET 4在CLR和BCL的一些变化(2)</title><link>https://lurongkai.github.io/posts/2010/04/12/dotnet-4-changes-on-clr-and-bcl-2/</link><pubDate>Mon, 12 Apr 2010 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2010/04/12/dotnet-4-changes-on-clr-and-bcl-2/</guid><description>上一篇讨论了.NET 4中关于垃圾回收、线程、并行、全球化等方面的内容，这次我们接着上次往下说。
安全 安全是一个很大的概念。在.NET 4中，主要的改进在于对CAS操作的简化。
先前的版本中，如果想要控制资源的安全访问，那么就会使用CAS策略，但是操作往往很复杂，4改进了操作，主要体现在这些方面：
改进的透明模型。透明模型将代码分为了安全、不安全、或许安全，当然，这取决于程序宿主机的设置。于是.NET为不同应用程序设置了不同的安全类型，就像我们平常知道的那样，ASP.NET和SQL, Silverlight可以运行代码的安全级别都不一样，这都是CAS策略所管理的。先前的透明模型主要和一些代码检查工具如FxCop等协同来审核代码。
透明模型有三种类型：透明代码、关键代码、安全关键代码，分别代表的代码的不同安全等级。当.NET 4的应用程序以部分信任运行时，CLR将确保透明代码可以调用其它的透明和安全的代码。并且，在程序调用安全的同时，CLR要求一定的权限才能执行，这个权限是通过程检查程序宿主机的设置来确认的。
与过去不同的是，.NET 4将通过Windows Explorer和网络共享运行的代码定义为完全信任，换句话讲，它们的等级是相同的，而先前的版本中，两者的运行等级并不相同。而运行在主机的应用程序，不管是ASP.NET或是Silverlight，将使用主机授权，也就是说我们只需要考虑授权这些应用程序以不同的权限。部分信任的应用程序已经对其有了必要的限制，对于非本机的代码，微软建议我们使用SRPs(Software Restriction Policies软件限制策略)来应用安全策略，这个东东可以在托管代码和非托管代码上应用，具体的大家查查MSDN。
新的版本中，已经删除了在CLR中有关Deny, RequestMinimum, RequestOptional, RequestRefuse的权限要求，所以说如果要迁移程序到新版本，一定要删除相关的代码才行，不然会报错。
缝缝补补，.NET 4终于可以不用像以前那样繁琐的来控制应用程序的权限相关的问题了。另外值得注意的是，.NET 4中有了一个PartialTrustVisibilityLevel的特性(Attribute)，使用这个特性，我们可以在部分信任的应用程序中，调用一些需要完全信任权限才能调用的程序集，这对于我们是一个好消息，尤其是ASP.NET应用程序。CAS的使用需要辅以“证据”，我们可以看看下图中CAS的构建模块：
.NET 4中的证据类型基类Evidence现在可以确保继承它的证据类型是非空和可序列化的。额外的，新加入了一些方法可以用于查询证据的具体类型，这在先前的版本中是通过遍历来实现的。
监测与分析 .NET 4的改进中不得不提的是，我们现在可以获取每个应用程序域关于CPU和内存的使用情况了，这对于ASP.NET应用程序是个不错的功能，很多时候我们需要知道应用程序的状况来做相关的优化时却措手无策，现在好了，新的改进可以使开发人员从容淡定的了解其应用程序的运行状况，然后淡定的修修补补，OK，效率上去了。
当然了，新的API肯定是有的，新增的API可以用做profiling和debugging，总的原则就是改善程序员的生存状态，不要累死在Debug上，嗯。
监测程序不正常的传统做法就是异常处理，我们经常这么做：
try { //Do some thing } catch(System.exception e) { //... } 这种做法很不推荐，因为所有的异常将被隐藏，然而我们往往希望一些异常不要被捕获，例如一些可以访问冲突或者调用非法指令的异常，这时应该让程序在出现异常时退出来而不是由catch将所有的异常捕获，因为这些异常具有一定潜在的危险性。.NET 4中引入了新的特性，那就是在方法体上标注[HandleProcessCorruptedStateExceptions]，这样，当破坏状态的异常出现时，将不会被catch捕获了。
那如果想捕获这些破坏状态的异常，比如将它传递到一个异常Logging类，好办，应用程序配置文件里加入这么一行：LegacyCorruptedStateExceptionsPolicy = true，catch就可以捕获到它了。
Dynamic的引入与DLR 这个特性绝对是.NET 4的重头戏，将它与Parallel特性封为4上最重要的功能一点也不过分。
先让我们来看一下先前版本的.NET对加入动态语言到.NET框架时是怎么做的：
可以看的出，Python和Ruby等这些动态语言是通过直接原生的在CLR上编写而实现移植。我们有理由想像在一个非动态的运行时上实现动态语言的难度是何等之大！
.NET 4提出的DLR是一个动态语言运行时，也就是说是微软官方提供的在CLR的基础上提供一层动态语言抽象层，来实现“门门语言为我，我为门门语言”的大友好框架主义，在此特性上，要移植一门动态语言到.NET平台上，好，去找DLR，那静态语言呢？直接去搞CLR。举个例子，今天我看上Javascript这姑娘了，想搞出个Javascript.NET，以实现我浏览器大友好.NET主义，理论上可行，可以联系DLR大哥；隔天又看上Java了……算了，我们换个例子，看上Scale了，好，给你张CLR的名片，我等.NET民众合谐友好。
那么具体的DLR在.NET 4所处的处置就是下面这个样子：
咦？C#和VB也可以使用DLR？当然了，为了交互的方便么。所以我们可以介绍怎样在C#等静态语言中使用动态语言的功能了。
于是我们有理由相信，.NET 4上的语言会越来越多，事实从一些消息上看，好像已经有二三十种的样子，著名的好像还是一些比较大的语言。当Python和Ruby在DLR上开始构建时，我相信可以实现的灵活度会大大提高。下面是官方的一张PPT：
当然了，这是编程层面的东西，例如C#和VB.NET其实是构建在CLR上的，只不过可以通过DLR来实现一些动态编程的特性。
.NET 4新加入的动态功能可以使我们方便的在运行时获取一个未知类型的对象并对其进行操作。同样的，构建在DLR基础上的动态语言也可以通过DLR -&amp;gt; CLR的方式来使用.NET类库。所以我们有理由相信，在使用COM方面，也将更加的简化。
动态语言是指在编译期不进行类型检查，在运行时动态的确定类型，这样的做的好处在于我们不必对未知的类型进行抽象，完全将其放在运行时动态的解析。然而其缺点也显而易见，那就是无法使用智能感知等强类型语言才拥有的特性，因此Debug也相对较困难一些。值得注意的是，动态语言的运行效率一定不会很高，因为在运行时进行解析是非常耗费资源的，并且对DLR来说，多一层抽象所带来的性能损失绝不对小视。我们可以想像一下将C#移植到Java平台上或者相反，理论上完全可行，因为.NET平台Java平台具有一定的相似性，对Java Bytecode和MSIL之间转换即可，然而效率问题确值得商榷。多一层抽象就多一层损耗，所以，在静态语言中使用动态特性一定要谨慎，不要滥用。
但是如果好奇，那么我们可以写个用反射来使用动态特性的Demo：
object UsingReflection = Activator.CreateInstance(Type.GetType(&amp;#34;System.Text.StringBuilder&amp;#34;)); Type ObjectType = UsingReflection.</description></item><item><title>.NET 4在CLR和BCL的一些变化(1)</title><link>https://lurongkai.github.io/posts/2010/04/11/dotnet-4-changes-on-clr-and-bcl-1/</link><pubDate>Sun, 11 Apr 2010 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2010/04/11/dotnet-4-changes-on-clr-and-bcl-1/</guid><description>VS2010明天就要发布了，伴随而来的是.NET Framework第四个版本的发布，借这个机会，聊聊相对于3.5，4又多了哪些新的特性。
我们知道，.NET Framework是一个渐近发展的框架，自从2.0开始，框架底层本身并没有太大的变化，CLR的版本都是2.0的，4的发布是一个质飞跃，微软直接跳过了CLR 3.0的版本而将.NET Framework的版本更新为4，如此看来，先前3.0，3.5的程序可以在2.0的运行时上运行，想在新的运行时上运行的话必须要重新编译了。
.Net Framework 3.0加入了一些诸如WPF,WCF,WF,WCS的东西，3.5又更新了一些EF，LINQ的新特性，那么我们有理由相信4也将会带给我们更多的惊喜，这个惊喜便是：Parallel和DLR。
GC CLR 2.0的运行机制大家一定很熟悉了，CLR为应用程序分配内存并且在适当的时候执行垃圾回收来释放内存。这里所说的适当可以理解为系统内存数量低或者其他对内存需求超过程合理范围的时候。
GC是怎么判断一个对象该执行清理了呢？CLR在内部建立了对象图来确定一个对象是否引用数为0，为0也就是不可达，清理之。CLR将分配内存的对象标记为0代，1代，2代，新分配的对象默认为0代，当CLR执行一次GC操作后没有被清理的对象将上升为1代，再清理，再升为2代，再清理，还是2代……不用多想，在CLR 2.0中最高就是2代。
GC的工作模式有3种：workstation, concurrent workstation, server，其中workstation是默认模式，而server模式用于多CPU服务器环境。workstation自不必细说，但是concurrent workstation模式下当一个GC正在执行中时，其他的GC是无法同时执行的。换句话讲，在concurrent workstation下GC的执行效率并不高，而server模式会开启一个新线程来进行GC操作，然而单个CPU上执行GC却和concurrent workstation相同。
那么CLR 4会有什么新的特性呢？一切为了效率，一切为了并行！CLR 4提出了后台GC来替代concurrent workstation模式。后台GC支持与其他的GC同时执行。换句话讲，减少了GC执行的时间，资源可以更早的被释放。
但是后台GC这种特性在server模式上却不可用，不知道在后续版本中会不会改进。
先前版本的GC运行机制详情请猛击PriorGC。
Cool，与Parallel不谋而合，并行真是大势所趋……
线程 线程上的改进主要在线程池上。
先前的线程池在获取线程信息上是很困难的，这不利于我们优化程序，于是.NET 4新提出了一个新的更加友好的数据结构：Task，较先前的ThreadPool而言效率更高，对GC也更加的友好。
一个简单的示例：
在.NET 4以前的版本里，我们可以这样使用线程池：
ThreadPool.QueueUserWorkItem(_ =&amp;gt; { Console.WriteLine(&amp;#34;Hello world!&amp;#34;); }); 而在.NET 4中我们多了些选择：
Task newTask = Task.Factory.StartNew(() =&amp;gt; Console.WriteLine(&amp;#34;Hello world!&amp;#34;)); 但是要注意到的是，现在我们可以通过程newTask.Status来获取一个TaskStatus枚举，这个枚举说明了当前Task的执行状态，当然了，还有很多的属性，总之，可以获取很多的运行时状态，而这一切在ThreadPool是做不到的。
并行 说到线程上的改进就不能不提.NET 4的并行特性。新加入的支持并行特性的有
TPL(Task Parallel Library并行任务库)和CCR(Concurrency and Coordination Runtime并发与协调运行时) PLINQ(并行LINQ) 并发数据结构 PPL(Parallel Pattern Library并行模式库) 当然了，还有一些支持并行开发的必要工具。大家知道并发和并行是两个不同的概念，主要体现在对CPU的使用方式上不同。并发多指的是多线程，而并行是多CPU同步执行，一个图示如下：
但是值得注意的是，并线与多线程会加重程序的复杂度。并行程序可以显著提高程序在多CPU环境下的执行效率，然而同步与死锁的问题仍然没有完美的解决，并且难于调试(虽然VS2010的IDE提供了很大的支持)，与多线程相同，在开发时要注意这一点。</description></item></channel></rss>