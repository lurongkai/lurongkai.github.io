<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Parallel on 程序物语</title><link>https://lurongkai.github.io/tags/parallel/</link><description>Recent content in Parallel on 程序物语</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 20 Apr 2010 00:00:00 +0800</lastBuildDate><atom:link href="https://lurongkai.github.io/tags/parallel/index.xml" rel="self" type="application/rss+xml"/><item><title>.NET 4中的并行编程(下)</title><link>https://lurongkai.github.io/posts/2010/04/20/dotnet-parallel-programming-2/</link><pubDate>Tue, 20 Apr 2010 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2010/04/20/dotnet-parallel-programming-2/</guid><description>上一次主要讨论了在.NET 4中如何编写并行程序，这次继续上次的话题。
当我们有能力使用前面所介绍的一些结构来构建我们的应用程序时，一个需要考虑的场景是：假如一个并行过程已经开始，在它没有完成前想取消它的话应该怎么做呢？其实这个问题很现实，在多线程程序中也会遇到，当然了，多线程编程时我们可以用Thread.Abort()来终结它，那么在并行中该如何实现呢？老规矩，上Demo：
CancellationTokenSource tokenSource = new CancellationTokenSource(); CancellationToken token = tokenSource.Token; Task task1 = Task.Factory.StartNew(() =&amp;gt; { int i = 0; while (!token.IsCancellationRequested) { Thread.Sleep(500); Console.WriteLine(&amp;#34;Task1,{0}&amp;#34;, i++); } }, token); token.Register(() =&amp;gt; { Console.WriteLine(&amp;#34;Task1 has been canceled&amp;#34;); }); Console.ReadLine(); tokenSource.Cancel(); 首先实例化一个CancellationTokenSource对象，这个对象用于管理并行过程中的取消动作。当创建一个Task的时候，传入一个CancellationToken对象，而这个对象可以由CancellationTokenSource.Token属性来获得。当Task开开始执行时，如果想取消这个Task，那么就可以调用CancellationTokenSource.Cancel()来取消与之相关的Task了。
其实，我们可以将CancellationTokenSource理解为一个犯罪团伙的头目，然后这个头目管理着CancellationToken小兵，然后当一个Task创建时将这个小兵安插在其中(无间道？)，当头目发指令Cancel()时，小兵在Task内部上演无间道，嗯……
然而，出来混，迟早要还的。Task能不能无异常的执行完毕还是个未知数。在.NET 4中，现在可以用AggregateException来处理这些异常了，它提供一种异常汇总机制，可以对未知的异常进行处理，上一个Demo：
Task task1 = Task.Factory.StartNew(() =&amp;gt; { Console.WriteLine(&amp;#34;Task1 completed.&amp;#34;); }); Task task2 = Task.Factory.StartNew(() =&amp;gt; { Console.WriteLine(&amp;#34;Task2 processing.</description></item><item><title>.NET 4中的并行编程(上)</title><link>https://lurongkai.github.io/posts/2010/04/19/dotnet-parallel-programming-1/</link><pubDate>Mon, 19 Apr 2010 00:00:00 +0800</pubDate><guid>https://lurongkai.github.io/posts/2010/04/19/dotnet-parallel-programming-1/</guid><description>并行是.NET 4中新加入的特性，为了使程序在多核心多CPU环境运行的更好、更快、更强大。
并发和并行是不一样的，并发最多可以算做是多线程，而所谓并行是将任务分散到不同的CPU上同时执行。尤其值得我们关注的是，在Web环境下的先天并行特性，使得并行编程成为解决性能瓶颈的又一武器。
.NET 4中的并行编程主要是Parallel和Task，微软强势构建了TPL(Task Parallel Library)，使开发过程变得简洁。
接下来，先看一个简单的Demo：
using System.Threading.Tasks; Parallel.Invoke( () =&amp;gt; { Thread.Sleep(1000); Console.WriteLine(&amp;#34;1&amp;#34;); }, () =&amp;gt; { Thread.Sleep(1000); Console.WriteLine(&amp;#34;2&amp;#34;); }, () =&amp;gt; { Thread.Sleep(1000); Console.WriteLine(&amp;#34;3&amp;#34;); }); Parallel.Invoke()方法可以接收一个Action委托的params数组。我们来猜一下上段代码的执行结果是什么？123的顺序还是132？213？231？这个，不一定，得看人品……呵呵，开个玩笑，并行执行时，将上面三个Lambda表达式传递的方法分别看做一个“任务”，将其分配至空闲CPU，然后执行，由于CPU的情况是不一定的，所以执行完毕的顺序也就有了差异。
由于很多需要并行执行的任务都有一定的相似性，所以一般情况下我们可以用一种类似for循环的方式对这些任务进行并行的处理，例如在.NET 4中可以这么做：
Parallel.For(0, 10, i =&amp;gt; { Console.WriteLine(i); }); 但样做有时却不方便，例如我们要处理一个集合中的数据，既然集合实现了IEnumerable接口，为什么还要用索引来遍历呢？
其实我们是可以方便并行的处理一个数据集合的，以在多CPU环境下获得更高的性能。具体的，我们可以这么做：
var dataList = new string[] { &amp;#34;data1&amp;#34;, &amp;#34;data2&amp;#34;, &amp;#34;data3&amp;#34; };//IEnumerable interface. Parallel.ForEach(dataList, taskOptions, data =&amp;gt; { Console.</description></item></channel></rss>